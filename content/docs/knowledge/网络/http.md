# HTTP

## 结构

### 请求报文结构

客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

请求报文结构：

第一行是包含了请求方法、URL、协议版本；
接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
一个空行用来分隔首部和内容主体 Body
最后是请求的内容主体

```md
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2

```


### 响应报文结构

第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
接下来多行也是首部内容
一个空行分隔首部和内容主体
最后是响应的内容主体

```md
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>

```



### 请求方法

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

按照RFC的定义:

- GET：请求指定的页面信息，并返回实体主体。
- HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。
- POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT：从客户端向服务器传送的数据取代指定的文档的内容。
- DELETE：请求服务器删除指定的页面。
- CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。

如果遵守RFC的定义去实现，那么 GET 方法就是安全且幂等的, POST 方法就是不安全且非幂等的。

这里的安全: GET方法是只读的，不会改变服务器的状态. 

幂等: 对同一URL的多次请求，返回的结果是一样的
- 因此可以对幂等的GET请求做缓存, 缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。

实际实现中:
- 是否幂等和安全，不是由方法本身决定的，而是由程序员的实现决定的。
- GET也可以带body.
- POST也可以带URL的参数.


### HTTP版本

见[版本](##版本)

### 状态码

1xx 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

2xx 类状态码表示**服务器成功处理**了客户端的请求，也是我们最愿意看到的状态。

- 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。

- 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

- 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3xx 类状态码表示**客户端请求的资源发生了变动**，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

- 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

- 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「304 Not Modified」不具有跳转的含义，表示资源未修改，**重定向已存在的缓冲文件，也称缓存重定向**，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。


4xx 类状态码表示**客户端发送的报文有误**，服务器无法处理，也就是错误码的含义。

- 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。

- 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。

- 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5xx 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

- 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

- 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。


### Content-Length

服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。


HTTP解决TCP "粘包" 问题的方法
- HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界
- 通过 Content-Length 字段作为 HTTP body 的边界

[TCP粘包问题](./TCP.md#面向字节流的协议)

### Connect

最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

[HTTP的keep-alive](./TCP.md#HTTP的keep-alive)

### 控制返回内容的字段

`Accept` 字段用于告诉服务器，客户端希望接收什么格式的数据。
- 例如：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9`

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
- 例如：`Content-Type: text/html; charset=UTF-8`

`Accept-Encoding` 字段用于告诉服务器，客户端支持的压缩格式。
- 例如：`Accept-Encoding: gzip, deflate`

`Content-Encoding` 字段用于服务器回应时，告诉客户端，本次数据采用了什么压缩格式。
- 例如：`Content-Encoding: gzip`


## HTTP缓存

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地. 下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

即, 通过缓存技术避免发送 HTTP 请求

HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。

### 强制缓存

只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。

![](img/HTTP/强制缓存.png)

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：

- Cache-Control， 是一个相对时间；
- Expires，是一个绝对时间；

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。

具体的实现流程如下：

1. 当浏览器第一次请求访问服务器资源时，**服务器**会在返回这个资源的同时，**在Response 头部加上 Cache-Control**，Cache-Control 中设置了过期时间大小；
2. 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，**如果没有，则使用该缓存，否则重新请求服务**
3. 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。


### 协商缓存

某些请求的响应码是 304

是服务端告知客户端可以使用本地缓存的资源,这种方式叫做协商缓存。

![](img/HTTP/协商缓存过程.png)


协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。

协商缓存可以基于两种头部来实现。

第一种：
- 响应头部中的 Last-Modified 字段: 标示这个响应资源的最后修改时间
- 请求头部中的 If-Modified-Since 字段: 服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，直接响应 HTTP 304 走缓存。


第二种：
- 响应头部中的 ETag 字段: 唯一标识响应资源
- 请求头部中的 If-None-Match 字段: 当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。


第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，Etag 优先级更高。

**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

- 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
- 可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
- 有些服务器不能精确获取文件的最后修改时间。


注意，协商缓存这两个字段**都需要配合强制缓存中 Cache-Control 字段**来使用. 
**只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。



## HTTPS

- HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

- HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

- HTTP 默认端口号是 80，HTTPS 默认端口号是 443。

- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

HTTP的风险
- 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
- 篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- 冒充风险，比如冒充淘宝网站，用户钱容易没。

HTTPS的解决方案
- 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
  - 使用**混合加密**
- 校验机制：无法篡改通信内容，篡改了就不能正常显示(但百度「竞价排名」依然可以搜索垃圾广告)
  - 使用**摘要算法**, 校验数据的完整性
- 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。
  - 公钥放入**数字证书**中.


### 混合加密

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

- **通信建立前**, 采用 **非对称加密的方式交换「会话秘钥」**
  - 这里是公钥加密，私钥解密 -- 保证内容安全
  - 公私钥是服务器生成的，私钥保密，公钥发送给客户端
  - 客户端使用公钥加密**协商生成的随机数**,用于**各自生成相同的「会话秘钥」**，发送给服务器，服务器使用私钥解密, 具体[见TLS握手](#TLS握手)
- 通信过程中, 全部使用 **对称加密的「会话秘钥」** 的方式加密明文数据。


采用「混合加密」的方式的原因：
- 对称加密只使用一个密钥，运算速度快，密钥必须保密，**无法做到安全的密钥交换**。
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。


### 摘要算法和数字签名

摘要算法（哈希函数）来计算出内容的哈希值

存在问题: 不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。


数字签名: 使用非对称加密算法对哈希值进行加密
- 这里是私钥加密，公钥解密 -- 保证数据完整性

私钥是由服务端保管，然后**服务端会向客户端颁发对应的公钥**。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

### 数字证书

数字证书是由 CA（证书权威机构）颁发的，用于证明服务器身份的一种方式。

即, 验证服务器最开始发送的公钥是否是**真实的服务器的公钥**

需要确定CA是可信的, CA有一对公私钥是可信的, 服务器和客户端都知道CA的公钥.

1. 服务器使用CA的公钥加密 `自己要提交证明的内容(服务器的公钥)`，发送给CA
2. CA使用自己的私钥解密，得到服务器的公钥
3. CA使用自己的私钥加密 `服务器的公钥`, 即做了数字签名, 颁发数字证书: `服务器信息 + 服务器的公钥 + CA的数字签名`

客户端验证服务器身份:
1. 客户端收到服务器的数字证书
2. 客户端使用CA的公钥解密数字签名，得到服务器的公钥, 证明服务器的公钥是真实的
3. 使用服务器的公钥进行后续加密

![](img/HTTP/数字证书颁发过程.png)


### TLS握手

1. 客户端向服务器索要并验证服务器的公钥。
2. 双方协商生产「会话秘钥」。

TLS握手可基于RSA算法和ECDHE算法

实际涉及四次通信:
1. 客户端向服务器发送一个「Client Hello」消息，包含了
   1. 客户端支持的SSL/TLS 版本
   2. 随机数(Client Random), 用于生成会话密钥
   3. 客户端支持的加密算法, 如RSA, AES等
2. 服务器收到「Client Hello」消息后，会回复一个「Server Hello」消息,包含了
   1. 确认TLS协议版本,如果浏览器不支持,则关闭加密通信
   2. 随机数(Server Random), 用于生成会话密钥
   3. 确认的加密算法
   4. **服务器的数字证书(包含服务器的公钥)**
3. 客户端收到「Server Hello」消息后，会验证服务器的数字证书，如果验证通过, 会生成一个随机数(pre-master key). **客户端将使用三个随机数生成「会话秘钥」**. 向服务器发送如下信息:
   1. 使用**服务器的公钥加密后**的一个随机数(pre-master key)
   2. 加密通信算法改变通知
   3. 客户端握手结束通知, 表示客户端握手阶段结束, 包含之前所有内容的摘要
4. 服务器收到客户端的信息后, 使用自己的私钥解密pre-master key, **使用三个随机数生成「会话秘钥」**, 之后发送如下信息:
   1. 加密通信算法改变通知
   2. 服务器握手结束通知, 表示服务器握手阶段结束, 包含之前所有内容的摘要


实际上, 上述过程会存在前向安全问题和证书信任链的问题

### 前向安全问题

RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

ECDHE 密钥协商算法解决了这个问题，目前大部分网站都使用 ECDHE 算法。

ECDHE 密钥协商算法是 DH 算法演进过来的。

#### TODO: DH算法

DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是离散对数。

根据私钥生成的方式，DH 算法分为两种实现：
- static DH 算法，这个是已经被废弃了；
- DHE 算法，现在常用的；

static DH 算法不具备前向安全性

DHE算法保证前向安全性: 双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。

ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。

#### 使用ECDHE算法的握手过程

第一次与RSA算法的握手过程一样[RSA握手过程](#TLS握手)，
1. 在第二次握手中,服务器还会发送「Server Key Exchange」消息
   1. 包括了服务端的椭圆曲线公钥
2. 客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端
   1. 最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。



### 证书信任链的问题

我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级:
![](img/HTTP/证书层级.png)

总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。

为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

这是为了**确保根证书的绝对安全性**，将根证书隔离地越严格越好，不然**根证书如果失守了，那么整个信任链都会有问题。**

### HTTPS 一定安全可靠吗？

问题场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个**「中间人服务器」**，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。


实际情况:
- 用户会收到一个「伪造的数字证书」，这个数字证书是「中间人服务器」伪造的.
- 如果用户同意信任这个数字证书，那么「中间人服务器」就可以解密客户端发来的数据，然后再加密转发给服务端，这样就实现了「中间人攻击」。

HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（**用户点击继续访问或者被恶意导入伪造的根证书**），并不是 HTTPS 不够安全。


也可以使用 **HTTPS 双向认证** 解决这个问题

![](img/HTTP/HTTPS双向认证.png)



## 版本及特性


[HTTP 是基于 TCP 还是 UDP 的](https://www.zhihu.com/question/20085992)

### HTTP/1.0


### HTTP/1.1


### HTTP/2

目前(2024.4)[Spring Web](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-http2.html)默认还是HTTP/2

### HTTP/3

HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 

#### HTTP/2的队头阻塞问题

-  HTTP/2.0 在单个 TCP 连接上使用了多路复用
   -  多个 HTTP 请求和响应共享一个 TCP 连接
- 受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞
  - 如果其中一个请求或响应因为网络拥塞或丢包而被阻塞
- 那么后续的请求或响应也无法发送，导致整个连接的效率降低



