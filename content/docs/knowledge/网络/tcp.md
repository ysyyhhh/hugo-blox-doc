
# TCP

## TCP和HTTP的keep-alive区别

### TCP的keep-alive

TCP 的 Keepalive 是 **TCP 的保活机制**，检测的是对端主机是否存活（而不是进程）

原理：

![](img/TCP/TCP保活机制.png)

1. 如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。
2. 如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。
3. 如果对端主机宕机（注意**不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文**，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机）。或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后没有响应，连续几次，**达到保活探测次数**后，TCP 会报告该 TCP 连接已经死亡。

TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，**这个工作是在内核完成的**。


默认情况：
默认情况TCP 保活机制是关闭的，应用程序需要通过设置需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效。

### HTTP的keep-alive

![](img/TCP/HTTP长连接.png)

HTTP 的 Keepalive 是 **HTTP 长连接**，目的是在一次TCP连接中可以发送多个HTTP请求，减少建立和关闭连接的开销。


在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：`Connection: Keep-Alive`。

在 HTTP 1.1 开始, 默认是开启的，如果要关闭 Keep-Alive，可以在请求的包头中添加：`Connection: close`。

HTTP长连接支持了HTTP流水线,但同时也带来了队头阻塞问题。

同时为了避免TCP连接一直保持，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。

#### HTTP 流水线

![](img/TCP/HTTP流水线.png)

HTTP 流水线: 客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应，可以减少整体的响应时间。

- 服务器还是按照顺序响应, 即先响应第一个请求，再响应第二个请求，以此类推。

- 而且要等服务器响应完客户端**第一批发送的请求**后，客户端**才能发出下一批的请求**

于是就有了队头阻塞问题，即前面的请求处理时间过长，导致后面的请求被阻塞。

#### 队头阻塞

实际上队头阻塞问题由两种,一种是TCP本身的队头阻塞，一种是HTTP的队头阻塞。

- TCP本身的队头阻塞：TCP是一个面向字节流的协议，如果一个数据包丢失，那么后面的数据包都会被阻塞，直到丢失的数据包被重传成功。
- HTTP/1.x 的队头阻塞: 当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞
- HTTP/2 的队头阻塞: HTTP/2 通过多路复用解决了HTTP/1.x的队头阻塞问题，可以同时发送多个请求，而且不会被阻塞。
- HTTP/3 的队头阻塞: HTTP/3 使用了 UDP + QUIC 协议，解决了TCP队头阻塞问题。



## 面向字节流的协议


