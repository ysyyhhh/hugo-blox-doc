# MySQL

39.Mysql的存储引擎有什么
40.Innodb的特性
41.Mysql有几种锁
42.怎么避免锁全表
43.Insert into和replace into有什么区别
44.Union和union all的区别
45.常用的几种连接
46.Join和leftjoin什么区别


MySQL


## 引擎

### **InnoDB和MyISAM的区别**

- **事务支持**：InnoDB支持事务，MyISAM不支持事务
- **外键支持**：InnoDB支持外键，MyISAM不支持外键
- **锁级别**：InnoDB支持行级锁，MyISAM支持表级锁
- **MVCC**：InnoDB支持MVCC，MyISAM不支持MVCC
- **表的具体行数**：InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。MyISAM保存表的具体行数，执行上述语句时直接读取保存的行数。
- **异常奔溃后的恢复**：InnoDB是崩溃后完全恢复（依赖redo log），MyISAM是损坏后无法恢复
- 索引实现不一样：InnoDB是聚集索引，MyISAM是非聚集索引



## 日志
MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。

![](img/MySQL/MySQL日志.png)

### 重做日志（redo log）

InnoDB存储引擎特有的日志

InnoDB存储引擎以页为单位进行数据的读写，为了减少IO开销，InnoDB会将数据先写入到内存中的缓冲池，然后再以一定的频率刷入到磁盘中。但是，如果在数据写入到磁盘之前，数据库发生了异常重启，那么内存中的数据就会丢失，这时就需要重做日志来恢复数据。

作用：保证事务的持久性，在数据库异常重启时，通过重做日志可以将数据恢复到异常重启之前的状态

内容：记录数据页的物理修改，而不是逻辑修改

redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。redo log 中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，甚至还可能会记录修改数据的长度（取决于 redo log 类型）。


#### 刷盘时机


事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。

什么时候释放

当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。

### 回滚日志（undo log）

undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。

作用：保证事务的原子性

内容：记录数据页的逻辑修改

在执行undo操作时，会将undo log中的数据写入到数据页中

事务开始之前就产生undo log

当事务提交之后，undo log并不能立马被删除，

而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。


### 二进制日志（binlog）

主要记录了对 MySQL 数据库执行了更改的所有操作(数据库执行的所有 DDL 和 DML 语句)，包括表结构变更（CREATE、ALTER、DROP TABLE…）、表数据修改（INSERT、UPDATE、DELETE...）

内容：包括执行了的sql语句和反向的sql语句

二进制记录格式：
- Statement 模式 ：每一条会修改数据的sql都会被记录在binlog中，如inserts, updates, deletes。
- Row 模式 （推荐）: 每一行的具体变更事件都会被记录在binlog中。
- Mixed 模式 ：Statement 模式和 Row 模式的混合。默认使用 Statement 模式，少数特殊具体场景自动切换到 Row 模式。

#### 用于主从复制

1. 主库将数据库中数据的变化写入到 binlog
2. 从库连接主库
3. 从库会创建一个 I/O 线程向主库请求更新的 binlog
4. 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收
5. 从库的 I/O 线程将接收的 binlog 写入到 relay log 中。
6. 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。

#### 刷盘时机

会先把日志写入到binlog cache中，只有在事务提交的时候，才会把binlog cache中的日志持久化到磁盘上的binlog文件中。写入内存的速度更快，这样做也是为了效率考虑。

可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。

那么 binlog 是什么时候刷到磁盘中的呢？ 可以通过  sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N，默认为 0 ：
0：不去强制要求，由系统自行判断何时写入磁盘；
1：每次提交事务的时候都要将binlog写入磁盘；
N：每 N 个事务，才会将binlog写入磁盘。

#### 重新生成binlog

当遇到以下 3 种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：
- MySQL服务器停止或重启；
- 使用 flush logs 命令后；
- binlog 文件大小超过 max_binlog_size变量的阈值后。

### 慢查询日志

慢查询日志记录了执行时间超过 long_query_time（默认是 10s，通常设置为1s）的所有查询语句，在解决 SQL 慢查询（SQL 执行时间过长）问题的时候经常会用到。

找到慢 SQL 是优化 SQL 语句性能的第一步，然后再用EXPLAIN 命令可以对慢 SQL 进行分析，获取执行计划的相关信息。

可以通过 show variables like "slow_query_log";命令来查看慢查询日志是否开启，默认是关闭的。

### 逻辑日志和物理日志

逻辑日志：记录的是逻辑操作，如insert、update、delete
- binlog
- undo log

物理日志：记录的是物理操作，如页的修改，如redo log
- redo log


## 读写分离(主从表)

读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。

一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。

### 如何实现读写分离

- 多台数据库, 1台主库, 多台从库
- 保证主从库的数据一致性 -- 主从复制
- 将写操作发送到主库，读操作发送到从库


#### 代理方式

在应用和数据中加一个代理层,代理层来分离读写请求.

类似的中间件有: 
- MySQL Pouter(官方)
- Mysql Proxy
- MaxScale
- MyCat

#### 组件方式

引入第三方组件来实现读写分离

如sharding-jdbc

### 主从复制的原理

基于二进制日志的复制  (binlog)

binlog记录了数据库执行的所有DDL和DML语句

过程:
- 主库将数据库变化写入binlog
- 从库连接到主库
- 创建一个IO线程请求主库的binlog
- 主库创建一个binlog dump线程,将binlog的内容发送给从库
- 从库的IO线程接收到binlog后,写入relay log
- 从库的SQL线程读取relay log,并执行其中的内容

应用:
- 阿里开源的 canal
- 分布式缓存组件 Redis 也是通过主从复制实现的读写分离。

### 如何避免主从延迟

问题: 写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题

1. 强制把读请求给主库
2. 延迟读取, 等待从库同步完成后再读取

## 锁

### 锁的类型

- 共享锁（S锁）：允许事务读取一行数据
- 排他锁（X锁）：允许事务删除或更新一行数据
- 读锁（R锁）：允许事务读取一行数据
- 写锁（W锁）：允许事务删除或更新一行数据
- 乐观锁：不加锁，通过版本号或时间戳来判断数据是否被修改
- 悲观锁：加锁，通过锁来保证数据的一致性
- 行锁：锁定一行数据
- 表锁：锁定整个表
- 间隙锁：锁定一个范围，但不包括记录本身
- 临键锁：锁定一个范围，包括记录本身
- 读写锁：读锁共享，写锁排他
- 自旋锁：不断循环检查锁是否释放
- 互斥锁：同一时间只允许一个线程访问共享资源

### 间隙锁


### MVCC

MVCC（Multi-Version Concurrency Control）多版本并发控制

用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。

当一个事务执行读操作时，它会使用快照读取。
当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。

当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。
当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。

为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。

InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：

1、执行普通 select，此时会以 MVCC 快照读的方式读取数据

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

2、执行 select...for update/lock in share mode、insert、update、delete 等当前读

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读

### 死锁

#### MYSQL中死锁的判断

使用SHOW ENGINE INNODB STATUS命令查看

#### 如何解除死锁

- 重试
- kill掉一个事务
- 优化SQL




## 分布式场景

### 分布式场景中如何保证主键的唯一性

- 使用全局唯一ID
- UUID 不依赖中心认证即可自动生成全局唯一ID。

32个十六进制数组成的字符串，且分隔为五个部分，如：
467e8542-2275-4163-95d6-7adc205580a9
各部分的数字个数为：8-4-4-4-12

#### 生成方式

- 基于时间戳
- 基于随机数
- 基于名字空间


#### 使用UUID的好处

- 生成简单，不依赖数据库
- 生成速度快

#### 使用UUID的坏处

- 无序性，不适合作为主键
- 占用空间大，16个字节



## SQL语法

### 修改表结构

增加一列
```sql
ALTER TABLE table_name ADD column_name column_definition;
```

修改某一列的类型
```sql
ALTER TABLE table_name MODIFY column_name column_type;
```

### 语句执行顺序


1. from
2. where
3. group by
4. having
5. select


exist 和 in 的区别
exist 是判断子查询是否有结果，in 是判断字段是否在子查询的结果中

EXISTS 子查询:

执行顺序为:

a. 先执行外层查询
b. 对于外层查询的每一行,执行内层 EXISTS 子查询
c. 如果内层子查询有结果,则外层行满足条件,否则不满足

这种执行顺序使得 EXISTS 子查询更加高效,因为一旦内层子查询有结果,就可以立即确定外层行满足条件,无需执行完整个子查询。

IN 子查询:

执行顺序为:

a. 先执行内层 IN 子查询,获取子查询的结果集
b. 然后对外层查询的每一行,检查是否在子查询的结果集中

与 EXISTS 不同,IN 子查询需要先完整执行内层子查询,才能判断外层行是否满足条件。
 
## 其他

MySQL的单表最大记录如何计算

a为索引字段占用的空间
b为非索引字段占用的空间

Total =  8000^3  / ( (a+4)^2 * (a+b+30) )



