# Redis基础

## Redis基础知识：

### Redis是什么？有什么用？

Redis是一个开源的内存数据结构存储系统。

1. Redis最常用来做缓存，是实现分布式缓存的首先中间件；
2. Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；
3. Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV、用户在线天数等数据；
4. Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用。

### 使用Redis的好处是什么？

使用Redis的好处包括高性能、高可用性、支持多种数据结构、支持事务和Lua脚本等。

### Redis与其他key-value存储的不同之处在哪里？

Redis与其他key-value存储的不同之处在于，Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等，而其他key-value存储通常只支持字符串类型。

### 比较Redis与Memcache

- Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合，支持事务和Lua脚本、支持持久化和复制等。
- Memcache只支持字符串类型。

### Redis是单进程单线程的吗

是的，Redis是单进程单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。

而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。

1. 对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；
2. Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；
3. Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

### Redis底层原理

Redis是一个单线程的应用程序，它使用了事件驱动模型来实现高性能的I/O操作。它的主要数据结构都是基于哈希表和链表实现的。对于读取操作，Redis会直接从内存中读取数据，因此具有很高的读取性能；对于写入操作，Redis会先将数据缓存在内存中，然后定期将数据写入磁盘中，因此具有较高的写入性能。此外，Redis还提供了多种持久化方式，包括RDB快照和AOF日志，可以满足不同场景下的需求。


### Redis的最大连接数如何配置，不配置会怎么样

在redis.conf的max_clients中设置

如果不配置,会使用默认值,默认值是10000

合理的最大连接数 = 最大并发量 / (1000ms / 每次请求耗时ms)


### Redis需要把所有数据放到内存中吗？

是的，Redis需要把所有数据放到内存中，是因为它采用了基于内存的数据存储方式，可以快速读写数据。


## Redis 命令

### Redis中的watch命令

很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。

Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。

客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。

26、Redis的密码可以通过哪些方式设置和验证？

Redis的密码可以通过配置文件设置，验证密码可以使用AUTH命令。

32、Redis集群可以选择不同的数据库吗？

Redis集群可以选择不同的数据库，通过SELECT命令进行切换。

33、如何测试Redis的连通性？

可以使用PING命令测试Redis的连通性。


## Redis数据结构

这里从原理的角度分析Redis的数据结构

一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个）

一个database通过一个dict结构来保存所有的键值对，其中key是一个字符串，value是一个RedisObject对象。

RedisObject对象是一个union结构，包含多种数据类型，其对应的底层数据结构分别是
- string
  - SDS(Simple Dynamic String)
- list
  - ZipList(压缩列表--特殊编码的双向链表)
- hash
  - dict, HashTable
- set
  - IntSet 整数集
- zset
  - ZSkipList(跳跃表)

### Redis的其他数据类型

1. Redis支持5种核心的数据类型，分别是字符串、哈希(是一个键值(key=>value)对集合)、列表、集合(set)、有序集合(zset)；
2. Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；
3. Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。

### set和zset有什么区别？

set：

- 集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；
- 集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。

使用的是哈希表数据结构，可以保证在O(1)的时间复杂度内完成插入、删除、查找等操作。

zset：

- 有序集合保留了集合元素不能重复的特点；
- 有序集合会给每个元素设置一个分数，并以此作为排序的依据；
- 有序集合不能包含相同的元素，但是不同元素的分数可以相同。

使用的是**跳表数据**结构，可以保证在O(log(N))的时间复杂度内完成插入、删除、查找等操作。

### 一个字符串类型的值能存储的最大容量是多少？

一个字符串类型的值能存储的最大容量是512MB。

### SDS 简答动态字符串

分为三部分: 
- 头部
  - len
  - alloc
  - flag
- 中间部分
  - buf
- \0


源码
```md
- len 保存了SDS保存字符串的长度
- buf[] 数组用来保存字符串的每个元素
- alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.
- flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用
```

有五种不同头部: 1 byte, sdshdr8, sdshdr16, sdshdr32, sdshdr64.
区别是alloc的大小不同, 以及len的大小不同.

优点:
- 获取字符串长度的时间复杂度为O(1)
- 杜绝缓冲区溢出--通过len和alloc来控制
- 减少内存重新分配次数,通过以下手段:
  - 空间预分配
  - 惰性空间释放
- 二进制安全 -- 通过len判断释放结束
- 可以使用<string.h>中的函数

### Redis中List结构的相关操作

列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储2^32-1个元素。列表包含如下的常用命令：

- lpush/rpush：从列表的左侧/右侧添加数据；
- lrange：指定索引范围，并返回这个范围内的数据；
- lindex：返回指定索引处的数据；
- lpop/rpop：从列表的左侧/右侧弹出一个数据；
- blpop/brpop：从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态。


#### 跳表和红黑树比较

跳表和红黑树都是有序的数据结构，它们的区别主要体现在以下几个方面：
1. 跳表是一种随机化的数据结构，插入、删除和查找的平均时间复杂度都是O(logN)，而红黑树是一种平衡二叉搜索树，插入、删除和查找的最坏时间复杂度都是O(logN)；
2. 跳表的实现比较简单，而红黑树的实现比较复杂；

跳表是通过随机函数来维护前面提到的平衡性。

为什么Redis的zset使用跳表

Redis的作者 @antirez 是怎么说的
1. 它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。
   1. 平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。
2. Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。
3. 它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。


## Redis持久化

### Redis的持久化机制有哪些？

RDB和AOF是Redis的两种持久化机制，它们都可以将Redis的数据保存到磁盘上，以便在Redis重启时恢复数据。但是它们的实现方式和适用场景有所不同。

- RDB是一种快照机制，它可以将Redis的内存数据保存到磁盘上。
  - RDB的实现方式是在指定的时间间隔内，将Redis的内存数据快照保存到磁盘上。快照文件的格式是二进制的，可以通过配置文件指定保存的文件名和路径。
  - RDB的优点是快速、简单、可靠，适合用于备份和恢复数据。缺点是可能会丢失最近一次快照之后的数据，因为快照是定期保存的。

- AOF是一种追加日志机制，它可以将Redis的写操作记录到磁盘上。
  - AOF的实现方式是将Redis的写操作以追加的方式记录到一个日志文件中，日志文件的格式是文本的。
  - AOF有三种同步方式：always、everysec和no。always表示每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；everysec表示每秒钟同步一次，可以平衡性能和数据安全；no表示不同步，性能最好，但是数据安全性最差。
  - AOF的优点是可以保证数据的完整性和一致性，适合用于数据持久化和灾备。缺点是日志文件可能会很大，需要定期进行压缩和重写。

在实际应用中，可以根据实际情况选择RDB和AOF中的一种或两种持久化机制。如果数据的安全性和一致性比较重要，可以选择AOF；如果数据的恢复速度比较重要，可以选择RDB；如果两者都比较重要，可以同时使用两种持久化机制。


### AOF 日志实现

先执行命令，再把数据写入日志

Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。

- 避免额外的检查开销：
- **不阻塞当前写**操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。

当然，这样做也会带来风险：

- 数据可能会丢失： 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。
- 可能阻塞其他操作： 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 **Redis 把日志文件写入磁盘时**，还是会阻塞后续的操作无法执行

#### AOF 写回策略

1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
2. 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
3. 具体**内核缓冲区的数据什么时候写入到硬盘，由内核决定**。
  - always：每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；
  - everysec：每秒钟同步一次，可以平衡性能和数据安全；
  - no：不同步，由操作系统控制写回，性能最好，但是数据安全性最差。

#### AOF 重写机制 -- 解决AOF 过大问题

当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

在重写时，**读取当前数据库中的所有键值对**，然后将每一个键值对用一条命令记录到「新的 AOF 文件」

重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的

- 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
- 子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。

写时复制，发生不一致怎么办
AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。

在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会**同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」**


![](img/Redis基础/AOF重写子进程.png)


主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：

- **将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件**中，使得新旧两个 AOF 文件所保存的数据库状态一致；
- 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

信号函数执行完后，主进程就可以继续像往常一样处理命令了。


### RDB快照

RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据
Redis 的快照是全量快照

Redis 恢复数据时，直接将 RDB 文件读入内存就可以，快速

RDB 做快照时会阻塞线程吗？

有两个命令来生成RDB文件，SAVE和BGSAVE
- SAVE会阻塞线程，直到RDB文件生成完毕
- BGSAVE不会阻塞线程，会fork一个子进程来生成RDB文件

Redis可以通过配置文件来实现每隔多久自动执行bgsave


RDB 在执行快照的时候，数据能修改吗？
可以修改，基于写时复制技术

![](img/Redis基础/fork子进程.png)

主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件

也就是写入RDB文件的数据是fork前的数据。

![](img/Redis基础/写时复制.png)

### 混合持久化

fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件

然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件

写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。

混合持久化优点：

- 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。

混合持久化缺点：

- AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
- 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了


### Redis的持久化机制的优缺点有哪些？

Redis的持久化机制包括RDB和AOF两种方式，各自的优缺点包括数据恢复速度、数据安全性、数据一致性等方面。

RDB方式是将Redis的内存数据快照保存到磁盘上，优点是恢复速度快，缺点是可能会丢失最近一次快照之后的数据。

AOF方式是将Redis的写操作以追加的方式记录到一个日志文件中，优点是可以保证数据的完整性和一致性，缺点是日志文件可能会很大。

### 大Key对持久化的影响


## Redis 事务


