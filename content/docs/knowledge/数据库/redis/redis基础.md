# Redis基础

## Redis基础知识：

### Redis是什么？有什么用？

Redis是一个开源的内存数据结构存储系统。

1. Redis最常用来做缓存，是实现分布式缓存的首先中间件；
2. Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；
3. Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV、用户在线天数等数据；
4. Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用。

### 使用Redis的好处是什么？

使用Redis的好处包括高性能、高可用性、支持多种数据结构、支持事务和Lua脚本等。

### Redis与其他key-value存储的不同之处在哪里？

Redis与其他key-value存储的不同之处在于，Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等，而其他key-value存储通常只支持字符串类型。

### 比较Redis与Memcache

- Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合，支持事务和Lua脚本、支持持久化和复制等。
- Memcache只支持字符串类型。

### Redis是单进程单线程的吗

是的，Redis是单进程单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。

而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。

1. 对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；
2. Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；
3. Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

### Redis底层原理

Redis是一个单线程的应用程序，它使用了事件驱动模型来实现高性能的I/O操作。它的主要数据结构都是基于哈希表和链表实现的。对于读取操作，Redis会直接从内存中读取数据，因此具有很高的读取性能；对于写入操作，Redis会先将数据缓存在内存中，然后定期将数据写入磁盘中，因此具有较高的写入性能。此外，Redis还提供了多种持久化方式，包括RDB快照和AOF日志，可以满足不同场景下的需求。


### Redis的最大连接数如何配置，不配置会怎么样

在redis.conf的max_clients中设置

如果不配置,会使用默认值,默认值是10000

合理的最大连接数 = 最大并发量 / (1000ms / 每次请求耗时ms)


## Redis 命令

### Redis中的watch命令

很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。

Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。

客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。


## Redis数据结构

这里从原理的角度分析Redis的数据结构

一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个）

一个database通过一个dict结构来保存所有的键值对，其中key是一个字符串，value是一个RedisObject对象。

RedisObject对象是一个union结构，包含多种数据类型，其对应的底层数据结构分别是
- string
  - SDS(Simple Dynamic String)
- list
  - ZipList(压缩列表--特殊编码的双向链表)
- hash
  - dict, HashTable
- set
  - IntSet 整数集
- zset
  - ZSkipList(跳跃表)

### Redis的其他数据类型

1. Redis支持5种核心的数据类型，分别是字符串、哈希(是一个键值(key=>value)对集合)、列表、集合(set)、有序集合(zset)；
2. Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；
3. Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。

### set和zset有什么区别？

set：

- 集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；
- 集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。

使用的是哈希表数据结构，可以保证在O(1)的时间复杂度内完成插入、删除、查找等操作。

zset：

- 有序集合保留了集合元素不能重复的特点；
- 有序集合会给每个元素设置一个分数，并以此作为排序的依据；
- 有序集合不能包含相同的元素，但是不同元素的分数可以相同。

使用的是**跳表数据**结构，可以保证在O(log(N))的时间复杂度内完成插入、删除、查找等操作。

### 一个字符串类型的值能存储的最大容量是多少？

一个字符串类型的值能存储的最大容量是512MB。


### SDS 简答动态字符串

分为三部分: 
- 头部
  - len
  - alloc
  - flag
- 中间部分
  - buf
- \0


源码
```md
- len 保存了SDS保存字符串的长度
- buf[] 数组用来保存字符串的每个元素
- alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.
- flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用
```

有五种不同头部: 1 byte, sdshdr8, sdshdr16, sdshdr32, sdshdr64.
区别是alloc的大小不同, 以及len的大小不同.


优点:
- 获取字符串长度的时间复杂度为O(1)
- 杜绝缓冲区溢出--通过len和alloc来控制
- 减少内存重新分配次数,通过以下手段:
  - 空间预分配
  - 惰性空间释放
- 二进制安全 -- 通过len判断释放结束
- 可以使用<string.h>中的函数



### Redis中List结构的相关操作

列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储2^32-1个元素。列表包含如下的常用命令：

- lpush/rpush：从列表的左侧/右侧添加数据；
- lrange：指定索引范围，并返回这个范围内的数据；
- lindex：返回指定索引处的数据；
- lpop/rpop：从列表的左侧/右侧弹出一个数据；
- blpop/brpop：从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态。


## Redis持久化

### Redis的持久化机制有哪些？

RDB和AOF是Redis的两种持久化机制，它们都可以将Redis的数据保存到磁盘上，以便在Redis重启时恢复数据。但是它们的实现方式和适用场景有所不同。

- RDB是一种快照机制，它可以将Redis的内存数据保存到磁盘上。
  - RDB的实现方式是在指定的时间间隔内，将Redis的内存数据快照保存到磁盘上。快照文件的格式是二进制的，可以通过配置文件指定保存的文件名和路径。
  - RDB的优点是快速、简单、可靠，适合用于备份和恢复数据。缺点是可能会丢失最近一次快照之后的数据，因为快照是定期保存的。

- AOF是一种追加日志机制，它可以将Redis的写操作记录到磁盘上。
  - AOF的实现方式是将Redis的写操作以追加的方式记录到一个日志文件中，日志文件的格式是文本的。
  - AOF有三种同步方式：always、everysec和no。always表示每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；everysec表示每秒钟同步一次，可以平衡性能和数据安全；no表示不同步，性能最好，但是数据安全性最差。
  - AOF的优点是可以保证数据的完整性和一致性，适合用于数据持久化和灾备。缺点是日志文件可能会很大，需要定期进行压缩和重写。

在实际应用中，可以根据实际情况选择RDB和AOF中的一种或两种持久化机制。如果数据的安全性和一致性比较重要，可以选择AOF；如果数据的恢复速度比较重要，可以选择RDB；如果两者都比较重要，可以同时使用两种持久化机制。

### 缓存雪崩、缓存穿透、缓存预热、缓存更新和缓存降级是什么？

#### 缓存穿透

客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。

解决方案：

1. 缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。
2. 布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。

#### 缓存击穿

一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。

解决方案：

1. 永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。
2. 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。

#### 缓存雪崩

在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。

解决方案：

1. 避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。
2. 启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。
3. 构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。



### Redis过期键的删除策略有哪些？

Redis过期键的删除策略包括定期删除和惰性删除。

惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。

定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描，

过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：

1. 从过期字典中随机选择20个key；
2. 删除这20个key中已过期的key；
3. 如果已过期key的比例超过25%，则重复步骤1。

### Redis的回收策略有哪些？

Redis的回收策略包括noeviction、allkeys-lru、volatile-lru、allkeys-random和volatile-random等。

### Redis的持久化机制的优缺点有哪些？

Redis的持久化机制包括RDB和AOF两种方式，各自的优缺点包括数据恢复速度、数据安全性、数据一致性等方面。

RDB方式是将Redis的内存数据快照保存到磁盘上，优点是恢复速度快，缺点是可能会丢失最近一次快照之后的数据。

AOF方式是将Redis的写操作以追加的方式记录到一个日志文件中，优点是可以保证数据的完整性和一致性，缺点是日志文件可能会很大。

### 保证缓存与数据库的双写一致性--

四种同步策略：

想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：

1. 先更新缓存，再更新数据库；
2. 先更新数据库，再更新缓存；
3. 先删除缓存，再更新数据库；
4. 先更新数据库，再删除缓存。

从这4种同步策略中，我们需要作出比较的是：

1. 更新缓存与删除缓存哪种方式更合适？
2. 应该先操作数据库还是先操作缓存？

更新缓存还是删除缓存：

下面，我们来分析一下，应该采用更新缓存还是删除缓存的方式。

- 更新缓存

  优点：每次数据变化都及时更新缓存，所以查询时不容易出现未命中的情况。

  缺点：更新缓存的消耗比较大。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。

- 删除缓存

  优点：操作简单，无论更新操作是否复杂，都是将缓存中的数据直接删除。

  缺点：删除缓存后，下一次查询缓存会出现未命中，这时需要重新读取一次数据库。

从上面的比较来看，一般情况下，删除缓存是更优的方案。

先操作数据库还是缓存：

下面，我们再来分析一下，应该先操作数据库还是先操作缓存。

首先，我们将先删除缓存与先更新数据库，在出现失败时进行一个对比：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645695077865/A8EAB406CDF2717DDC4C9AB91E37092E)

如上图，是先删除缓存再更新数据库，在出现失败时可能出现的问题：

1. 进程A删除缓存成功；
2. 进程A更新数据库失败；
3. 进程B从缓存中读取数据；
4. 由于缓存被删，进程B无法从缓存中得到数据，进而从数据库读取数据；
5. 进程B从数据库成功获取数据，然后将数据更新到了缓存。

最终，缓存和数据库的数据是一致的，但仍然是旧的数据。而我们的期望是二者数据一致，并且是新的数据。

### 你要如何设计Redis的过期时间？

1. 热点数据不设置过期时间，使其达到“物理”上的永不过期，可以避免缓存击穿问题；
2. 在设置过期时间时，可以附加一个随机数，避免大量的key同时过期，导致缓存雪崩。


## Redis 事务

