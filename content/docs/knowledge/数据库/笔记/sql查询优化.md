4.1关系代数

4.2查询优化器

4.3使用SQL需要考虑的因素

4.4查询的过滤条件

4.5高效过滤条件举例

4.6 SQL优化的其它问题-where子的比较运算符

4.7 SQL优化的其它问题-SQL连接



## 1.关系代数

代数的作用： 表达式的等价代换

2、3、4 这些数字对应的就是 关系(表)

+-x/这些运算符对应的就是 关系操作

SQL语句的本质是关系表达式

![image-20230309153407418](img/Sql查询优化/image-20230309153407418.png)

查询优化器 的作用 ： 就是在数据库中间进行关系表达式等价变化后找到最优路径

关系代数是**以数学为基础**的，是一个科学
在写代码时，像一个工匠。
关系数据库不一样，写的SQL只是向数据库提出取什么样数据的要求，具体怎么找到最快速的执行方式，是数据库的查询优化器的事情。

关系数据库还有一个科学的地方，它**存在简单模式，实现冗余最小的设计**。

- 没有简单通用的规则，实现数据库冗余最小。

- windows的资源管理器的目录结构、XML这种树形结构，这种文件组织方式是最习惯但不科学的

no sql 是 not only sql

## 2.查询优化器

**sql 关系理论 查询优化器的关系**：

![image-20230309153946870](img/Sql查询优化/image-20230309153946870.png)

关系理论适用于理论意义上无限大的集合。

在不同大小的数据集在不同物理环境中间，如何实现更有效率地读取，**将无限收缩到有限的环境中**，这就是查询优化器干的事情。

优化器借助关系理论提供的**语义无误的原始查询进行有效的等价变换**。

优化器的工作：

- 优化是在数据真正要被执行的时候才发生的;
- 有相同结果，但写法不同的关系表达式在实际环境下执行的效率相差很大:
- OceanBase的查询优化则是一个**规则优化和代价优化相结合**的过程，其主体是基于成本进行查询优化，并在查询优化过程中通过规则进行启发和剪枝。
  - 以前更多是基于规则的优化器 RBO, 现在大多数用的是基于成本的优化器 CBO



**sql的执行顺序**

**解析是SQL优化是最消耗资源的过程.** 

从解析中选择执行计划

![image-20230309155255554](img/Sql查询优化/image-20230309155255554.png)

- 你的**SQL仍然是它优化的起点**，是它选择优化路径的提示，不同的SQL写法，会对查询优化器最终选择的路径产生影响。
- 查询优化器不知道一些**影响实际执行效率的重要的信息**，而这只有写SOL的程序员知道。

### 2.1查看查询优化器的执行计划

**Oracle的执行计划**

![image-20230309155531599](img/Sql查询优化/image-20230309155531599.png)

在使用explain plan for语句时，跟在后面的SQL并不真正执行，执行计划表中的数据和操作都是预估的，

好处是，方便快捷，不影响数据库数据.

缺点是，没有输出相关统计信息。

![image-20230309155611613](img/Sql查询优化/image-20230309155611613.png)

**MySql的执行计划**:

![image-20230309155731369](img/Sql查询优化/image-20230309155731369.png)

第七列key:实际使用的索引;

第十列rows:估算的找到所需数据需读取的行数:

第十一列filtered:返回结果的行数占读取行数的百分比，值越大越好:


**OceanBase的执行计划**:

![image-20230309155810560](img/Sql查询优化/image-20230309155810560.png)



### 2.2查询优化器的有效范围

1. **1优化器需要借助数据库中找到的信息**。

一是**普通统计数据**，二是数据定义中重要的**声明信息**

尽量要把数据约束的语义信息在**数据库的声明中体现**，这样优化器就可以利用数据取值范围这样的语义信息来做优化决策. 

2. 只有能够进行数学意义上的**等价变换**，优化效果才最佳。

   对于查询中的非关系部分优化器可借助的理论基础不多，优化结果和原始语句写法所指定的方式相差无几

3. 一个独立执行的查询，优化效果可能很好，但把它嵌入一个更为复杂的查询内部，可能优化的效果就变差了

   优化器需要考虑**整体响应时间**

   **预计需要查询越久的,查询优化器会花更多的时间去找优化路径.**

4. 优化器改善的是**独立查询**

   优化器无法使独立的查询联系在一起进行统一优化，所以，如果通过过程化的编程提取了数据，再将数据传递到后续查询中，优化器是没有办法进行统一优化的



## 3.使用SQL需要考虑的因素

需要考虑的五大要素:

- 获得结果集所需访问的数据量
- 定义结果集所需的查询条件
- 结果集的大小获得
- 结果集所涉及的表的数量
- 同时修改这些数据用户的多少

### 3.1数据总量

SQL考虑**最重要因素:必须访问的数据总量**

没有**确定目标数据容量**之前，很难断定查询执行的效率,这是后续所有工作的基础.

### 3.2定义结果集的查询条件

一个或几个数据表，经过Join操作，再通过查询条件的选择，会产生一个SQL查询的结果集，完成我们的查询。

**从数据表到 结果集 发生的变化就是 查询条件**

查询条件是SQL优化的关键因素，也是写SQL的重要部分

过滤条件的效率有高有低，受到其它因素的影响很大

如果一个查询条件能剔除掉更多的数据，也就是满足这个查询条件的记录数很少，我们就称之为**高效的过滤条件**。

**寻找高效的过滤条件是程序员写SQL需要重点考虑的问题**


### 3.3结果集的大小

查询所返回的数据量，重要而被忽略

取决于表的大小和**过滤条件的细节**

例外是 若干个**独立使用效率不高的条件结合起来效率非常高**, 如双学位

从技术角度来看，查询结果集的**大小并不重要**，**重要的是用户的感觉**

熟练的开发者应该努力使**响应时间与返回的记录数成正比**.

### 3.4表的数量

from中间连接表的数量对性能有很大影响,尽管现在的DBMS都可以高效地连接多个表.

表的 join连接

- (太)多表连接该质疑设计的正确性了
- 对于**优化器**，随着表数量的增加，复杂度将呈指数增长
- 编写 (太)多表的复杂查询时，**多种方式连接的选择失误的几率很高**。

在一个查询中间, 避免连接太多的表



### 3.5并发用户数

设计sql时,随时**要关注并发性**, 并发量大会导致原先并发量小时效率高的设计变得极低.

- 数据块访问争用(block-accesscontention)
- 阻塞(locking)
- 闩定(latching)
- 保证读取一致性(read consistency)

警惕多米诺骨牌一样的现象, 如内存不够用导致硬盘资源争夺, 进而导致其他cpu负载过重.

也会有反例:

DBA增加物理I/0操作，反而会使任务执行效率更高，因为某些计算密集型操作的并发执行程度很高，一个进程刚刚因等待I/O操作而阻塞，它释放出来的CPU就被另一个进程占用了，这样CPU的资源反而被充分利用了。

必须要**考虑整体吞吐量,而不是个人响应时间**.



## 4.查询的过滤条件

### 4.1过滤条件的分类

如何限定结果集是最为关键的因素.

过滤条件主要是指Where子句中的各种各样的条件 也包括having

有些过滤条件直接作用于select运算符. 如某字段是否满足条件.

还有其他用于连接表的. 可以分成如下两种:

- Join过滤条件
- Select过滤条件

![image-20230309162132327](img/Sql查询优化/image-20230309162132327.png)

不一定哪个效率快, 运行效率和优化器有关系，不同的写法首先是影响了优化器**进行路径选择的起始点**.

在没有效率问题的情况下，SQL的写法无关紧要，但是在**有效率问题的情况下，SQL的写法就会导致效率有很大差别。**

**其他类型的条件**:

检查另一个表内是否存在特定数据的条件

sql语法上类似,但语义上完全不同.

### 4.2过滤条件的含义

过滤条件的计算顺序有时候会影响效率.

![image-20230309162532396](img/Sql查询优化/image-20230309162532396.png)

此时计算顺序无关紧要,但再加入一个条件:

![image-20230309162644909](img/Sql查询优化/image-20230309162644909.png)

在有些数据库中，试图把非数字字符串转化为整数的时候，会造成运行错误的问题.

一般来说，数据库有一个基本的原则，就是对于where子句的条件如果优化器在优化的过程中没有什么理由和原因的话，一般是**按照顺序执行的**

**mysql是从左到右, Oracle 是从右到左.**

where**的顺序是很重要的**



### 4.3基本原则

好的过滤条件要先做

能过滤掉更多数据的条件也就是满足这个条件的记录越少，这个条件越好

因为中间结果集的大小会不一样, 会影响性能.

在复杂的高并发大数据量的系统中，一个查询的执行计划往往要做很多步骤，**中间结果集的大小**，会从整体上影响整个系统的吞吐量中间结果集过大，会对缓存、硬盘、CPU都造成压力。

更重要的是，哪个过滤条件好，哪个过滤条件坏，查询优化器不一定知道，这是只有知道业务需求的程序员才知道的事情。

写SQL前要对过滤条件排序，去寻找高效的过滤条件

真正高效的过滤条件是查询的主要驱动力，低效条件只是为了业务要求的正确性对高效的过滤条件起到辅助筛选的作用。

定义高效过滤条件的准则:是否能够尽快减少必须处理的数据总量

思考题:你能列举出哪些where字句中用于过滤的关键字呢?



## 5.高效过滤条件的举例

![image-20230309163212559](img/Sql查询优化/image-20230309163212559.png)

![image-20230309163223970](img/Sql查询优化/image-20230309163223970.png)

和join on指定的条件相关,也和过滤条件的顺序相关.

古老的方式:

![image-20230309163403832](img/Sql查询优化/image-20230309163403832.png)

没有适用于所有情况的解决方案.

但上面的用了distinct,会把同名的人给合并.

避免在最高层distinct应该是一条基本规则; 因为即便遗漏了连接的条件,仍然会正常允许.

现实中,应该返回具有唯一性的客户ID和客户名，以保证得到BMW买家的完整清单

**摆脱distinct的方法**

**关联子查询**:

![image-20230309163645545](img/Sql查询优化/image-20230309163645545.png)

缺点, 子查询执行很多次. 取决于 第一个过滤条件的好坏.

**非关联子查询**:

![image-20230309163825049](img/Sql查询优化/image-20230309163825049.png)





找到分辨率最强的条件

- 解决方案不止一种，查询和数据隐含的假设密切相关
- 预先考虑优化器的工作，以确定它能找到所需要的数据

![image-20230309163932229](img/Sql查询优化/image-20230309163932229.png)

## 6.SQL优化的其他问题

### 6.1SQL的连接问题

第一个问题是**滥用子查询**,

子查询有两个好处:

- 分辨过滤条件的好坏
- 避免顶层的distinct

但如果没有以上两个好处,不如把选择权交给查询优化器.

![image-20230309164152188](img/Sql查询优化/image-20230309164152188.png)



但还有一种情况,**杜绝使用子查询**

![image-20230309164315664](img/Sql查询优化/image-20230309164315664.png)

以上方法性能很差.,因为是要选择没有分配的.

应该用out join

![image-20230309164344992](img/Sql查询优化/image-20230309164344992.png)



### 把聚合子查询转化为JOIN或内嵌视图

![image-20230309164543277](img/Sql查询优化/image-20230309164543277.png)

![image-20230309164638238](img/Sql查询优化/image-20230309164638238.png)

上面orderstatus被访问了多次

可以做成非关联嵌套子查询

![image-20230309164738725](img/Sql查询优化/image-20230309164738725.png)

但性能还有问题.

要告诉优化器,先获得子查询的结果集再连接这个表.

![image-20230309164849679](img/Sql查询优化/image-20230309164849679.png)

最好是使用内嵌的视图.

![image-20230309164936407](img/Sql查询优化/image-20230309164936407.png)

虽然做了一次大表遍历,但省了连接.

但如果状态很多,还需要用OLAP或者SQL引擎来进行优化.



![image-20230309165102184](img/Sql查询优化/image-20230309165102184.png)



```sql
select from (select max(totalitems) as mx,custid from orders group by custid) o1 join orders o2 where o1.mx = o2.totalitems and o1.custid = o2.custid
```















