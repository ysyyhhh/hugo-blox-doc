数据库表结构设计

- 不同设计对相同的查询会产生什么样不同的效率影响。
- 打破范式可以提高效率.

## 1.处理层次结构

以人类最熟悉的数据存储组织的方式最早出现
层次数据库存储数据存在一种逻辑嵌套，不是一种对数据的线性排列. 后续还出现了多重层次连接的网状数据库.

直到关系理论出现, 使得操控的灵活性，数据的组织，以及数据访问的效率上，找到了一个非常好的平衡

但层次组织数据的方式还是有很多的使用. 如:XML,LDAP都是基于树状结构的层次组织.

**层次结构复杂的原因**:

- 访问数据的方式，本质是一个访问树的方式，需要访问树的全部或者
  部分节点。
- 通常需要按照访问顺序返回这些数据.
- **过程化的访问方式，是违背关系理论**的，造成了一种**mismatch**。
- 在关系结构中，构建层次数据的存储和访问都很困难。

树状结构有三种表结构的设计方式，都是满足三范式三种完全不同的设计方式

### 1.1邻接模型

层次中父记录ID作为子记录(childrow) 的一个属性，树中两个相邻的节点

因而被明确关联在一一起。

设计直观简单,但会导致**递归的查询**。

### 1.2物化路径模型

把树中的每个节点、与它
在树中的位置的描述数据相结合。

1代表第一章;

1. 2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。

**与邻接模型的差别**:

- 邻接模型的子节点是平等的
- 物化路径模型可以指出**兄弟的排名**。
- 且可以无限扩展,扩展很多层。

### 1.3嵌套集合模型

每个节点被赋予了一对数字，其中父节点的两个数字包含其所有的子节点的左右数字，然后一层一层
这样包含下去。

### 1.4嵌套间隔模型(nested interval)

思想是以两个数字为特定节点的**路径编码**，这两个数字被解释成有理数(就是分数)的**分子和分母**。  太复杂了不讲.





### 1.5树状结构的三种方式访问的比较

例子 **军队结构**.

**邻接模型**

![image-20230309190604145](img/层次结构处理及反范式/image-20230309190604145.png)

![image-20230227192057736](img/层次结构处理及反范式/image-20230227192057736.png)



**物化路径模型**

![image-20230309190631784](img/层次结构处理及反范式/image-20230309190631784.png)

![image-20230227192122633](img/层次结构处理及反范式/image-20230227192122633.png)

**嵌套集合模型**

![image-20230227192142928](img/层次结构处理及反范式/image-20230227192142928.png)

特征:节点[left_num,right_num]值必定介于其任一个祖先的[left_num,right_num]值之间，这就是“嵌套集合”的由来。(nested set)

叶子结点即right_num = left_num + 1

![image-20230227192211959](img/层次结构处理及反范式/image-20230227192211959.png)



## 2.层次结构的自顶向下查询

![image-20230227192330951](img/层次结构处理及反范式/image-20230227192330951.png)

![image-20230309190847607](img/层次结构处理及反范式/image-20230309190847607.png)

以下用oracle

### 邻接模型

oracle专有关键词：ocean base也支持

![image-20230309190953499](img/层次结构处理及反范式/image-20230309190953499.png)

使用了虚拟的level字段。

不用connect by时，需要使用with as来递归

![image-20230309191109258](img/层次结构处理及反范式/image-20230309191109258.png)

![image-20230309191120429](img/层次结构处理及反范式/image-20230309191120429.png)

![image-20230227192536512](img/层次结构处理及反范式/image-20230227192536512.png)

with as 实现。但是层次遍历，不是深度优先遍历。

需要**定义层次**来进行重新的排序。

![image-20230309191243402](img/层次结构处理及反范式/image-20230309191243402.png)



便捷的方法是用connectted by

**mysql的问题**

MySQL8.0添加了CTE支持with as

8.0之前版本;两个方法手动union在一个查询中多次连接



### 物化路径模型

- 查询编写不困难
- 计算由路径导出的
- 层次不方便假设
- mp_depth(函数返回当前节点深度) 用字符串处理"."

![image-20230227192847984](img/层次结构处理及反范式/image-20230227192847984.png)

### 嵌套集合模型

![image-20230309191511744](img/层次结构处理及反范式/image-20230309191511744.png)

兄弟节点要排序就很复杂。

计算节点数量无法从leftnum和right_num导出.

![image-20230309191542150](img/层次结构处理及反范式/image-20230309191542150.png)





### 比较性能的方法

![image-20230227193009108](img/层次结构处理及反范式/image-20230227193009108.png)



**影响物化路径模型的因素**

1.计算深度
计算两个字符串函数的差，所带来的代价;

2.缩排函数
物化路径模型需**不断地处理字符串**，在where子句中不断的执行字符
串操作，处理速度比邻接模型更慢。

**嵌套集合模型**

找后代方面胜于其他两个模型，但为**缩排**付出更大代价;

性能的降低和额外连接，以及group by所做的深度有关

改善嵌套集合模型性能,其代价巨大

## 5.自底向上的查询 Hightland查询

**自底向上查询的特点**:

- 自顶向下查询只有一个起点; 而自底向上查询**可能有多个出发点**。
  ·多个记录都包含highland查询。

- 在description字段中查找“Highland”字符,
  必然**导致完整表扫描**.

**自底向上查询效率慢于自顶向下查询**

### 5.1邻接模型

![image-20230309192326051](img/层次结构处理及反范式/image-20230309192326051.png)

connect by 不是关系操作, 是基于过程的关键词,**不存储中间结果集**,

### 5.2物化路径模型

![image-20230309192441538](img/层次结构处理及反范式/image-20230309192441538.png)

**重复项和记录顺序的问题的解决方式**

![image-20230309192517555](img/层次结构处理及反范式/image-20230309192517555.png)

另一种方式把节点的物化路径分解成路径列表，即列转行的方式.

树状结构表增加到千行以上，like比较方法性能风险可能会大大提升



### 5.3嵌套集合查询

![image-20230227193634675](img/层次结构处理及反范式/image-20230227193634675.png)





### 5.4比较效率

![image-20230227193659877](img/层次结构处理及反范式/image-20230227193659877.png)

结果 connect by 查询效果依旧卓越.

物化路径和嵌套集合模型都只有邻接模型的一半的效率。

- 物化路径不该是主键，即使它们有唯一性。字符串不适合做主键且主键最好不要更新.
- 所选择的编码方式不需要完全中立
  - F.3.1.1 变成 F030101
  - 但这种方法不通用.

## 4.聚合来自树的值

一.对保存于**叶节点中的值做聚合**; 简单的树,单一父节点

二.计算某个值散布在树中各层次的百分比。

### 4.1第一个查询

![image-20230309193055261](img/层次结构处理及反范式/image-20230309193055261.png)

**对于邻接模型**

![image-20230227194121906](img/层次结构处理及反范式/image-20230227194121906.png)

**对于物化路径模型**

![image-20230309193243048](img/层次结构处理及反范式/image-20230309193243048.png)

性能差异

![image-20230309193319263](img/层次结构处理及反范式/image-20230309193319263.png)



### 4.2第二个问题 多父节点时,无法在一张表中解决

邻接模型和物化路径模型设计仍然存在局限性;

物料单位问题 BOM问题

![image-20230227194421886](img/层次结构处理及反范式/image-20230227194421886.png)

**出现的问题**:

一、龙蛋壳成分有多个父
节点，5号魔药和9号基础魔药都是它的父亲节点。

二、计算龙蛋壳在5号魔
药中占比，不仅要计算5号魔药本身的龙蛋壳的百
分比，还要加上9号魔药
中龙蛋壳的含量。



**解决方案:**

![image-20230227194512062](img/层次结构处理及反范式/image-20230227194512062.png)

一个components包含多个composition，一个处方，也包含多个composition。

![image-20230309193629175](img/层次结构处理及反范式/image-20230309193629175.png)

用with as 做递归

![image-20230309193641103](img/层次结构处理及反范式/image-20230309193641103.png)

### 4.3树状结构问题

关系型数据库非常难处理树状结构

因为性能非常差，处理层次型数据很困难。
SQL缺乏处理树结构的
强大的、可伸缩的手段。

不同的表结构设计，在相同的查询下，性能也会差距甚大.

不建议对关系模型不建议对屡遭诟病的缓慢本性 反规范化，这很容易遮掩程序设计中的问题

## 5.对冗余的控制（反范式）

### 5.1范式的概念

1NF:一个字段，只有一
个值。

2NF:一条记录，可以被唯一的主键所区分，是一个实体有唯一的标识。

3NF :字段和字段之间不存在函数依赖。

设置范式的原因： **控制冗余**

- 如果一个值，在关系型数据库中存在多个地方，那么他们应该一起被修改，否则数据完整性就没有办法保障了
- 但数据访问压力大，需从数据库设计入手，通过打破三范式提高数据库访问的性能。

打破范式的根本逻辑在于**降低表连接数量**。
提升了查询效率，降低了SQL优化器的优化难度。



### 5.2第一范式

含义：一个字段只有一个值;
不仅仅是存储的要求，也同样是**使用的要求**。

满足一范式的本质:把这个字段**只当成一个值**来使用，不能拆散使用。

如：身份证号码不和 生日 产生依赖。

**判断三范式**

- 一个字段的全部，不能和其它字段产生函数依赖。
- 而不是一个字段的一-部分是不是和其它字段产生函数依赖。
- 任何拆分字段的使用方式，本质上都是打破了一范式。

**三范式的实践基础**

一个字段只当成一个值使用。
生日和年龄是函数依赖关系，身份证号码和生日在实践意义上并不构成函数依赖。



### 5.3打破范式的本质

引入**受控的冗余**，确定是否通过放松规范化规则来提高系统的性能。

规范化的结果是一个结构上拥有**一致且最少冗余**的逻辑数据库设计。

有必要放弃完全规范化而得到某些性能上的好处。

**一旦打破范式需要考虑的三因素**

- 规范弱化使得**实现变得更加复杂**，因为需要**手动保持数据的完整性**。
  
- 规范弱化会**降低灵活性**。
- 规范弱化会加快元组检索的速度，但却会**使更新速度变慢**。



**通常的经验**：

80%的性能问题来自于开发和对数据库的使用不当，

**但如果系统具有低修改性和高查询率，规范弱化可能是提高数据库**
**查询效率一种可行的选择。**

用复制的方式打破范式，比如将某些属性或者将某些关系连
接起来，以**减少执行查询时所需要的连接操作**。



规范弱化取决于系统具体情况。

### 规范弱化模式

了解打破范式的几种手段，按照相应模式需求，构建手动的方式保证数据的完整性

![image-20230227195347207](img/层次结构处理及反范式/image-20230227195347207.png)

打破范式的步骤：

画好ER模型→分辨一对一、一对多和多对多关系→构建三范式表结构设计。

## 6.反范式的实现

### 6.1合并一对一关系

![image-20230309194735438](img/层次结构处理及反范式/image-20230309194735438.png)

合并：基于全部参与的实体为主，引入部分参与的表。

![image-20230227195601373](img/层次结构处理及反范式/image-20230227195601373.png)

产生空值。

### 6.2复制一对多关系中的非键列来减少连接

在子表中复制一个或更多的**父表中非键列来减少或删除链接**

![image-20230227195721370](img/层次结构处理及反范式/image-20230227195721370.png)

此时最需要关注更新，可能需要**使用触发器**。



### 3.复制一对多关系中的外键列来减少连接

为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。

![image-20230309194939656](img/层次结构处理及反范式/image-20230309194939656.png)

![image-20230227195815024](img/层次结构处理及反范式/image-20230227195815024.png)



### 6.4复制多对多的列

![image-20230227195834238](img/层次结构处理及反范式/image-20230227195834238.png)



### 6.5引入重复组

重复组：一组地址，一组电话号码，用户有多个。

满足范式要求:单独建一张地址或者电话的表，做连接查询。



打破方法：

- 把重复组全部打包放在主表中，增加n列
  - 1)重复组的绝对数量是已知的
  - 2该数量是静态的，不会改变
  - 3) 该数量并不是很大，通常不大于10
- 主表中存储缺省的电话和地址，所有地址和电话都单独存在地址表和电
  话表中。
  - 大部分查询，只需要缺省值。
  - 优点:通用性和效率都可以达到很好的平衡
  - 缺点：需要在UI中分开
  - 缺省值的读取和全部值的读取都在不同页面。



### 6.6创建提取表

将查询慢需要的表连接成
大表并储存下来。

查询可以访问派生数据并
在同一组基表上执行多表联接。

不能做实时计算，得到数据可能是**相对静态**
的，也可能不一定是最新的。

好处大，缺点非常大

带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间



### 6.7关于打破范式

![image-20230227200214330](img/层次结构处理及反范式/image-20230227200214330.png)

受控的冗余引入，冗余不可怕，但需要受控。



### 6.8总结

四个角度讨论查询优化的问题：

![image-20230309195507718](img/层次结构处理及反范式/image-20230309195507718.png)
