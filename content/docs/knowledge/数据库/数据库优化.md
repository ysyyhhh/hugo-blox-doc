

## 布隆过滤器


## SQL优化

### **Sql中使用绑定变量的优点与缺点**

**绑定变量实质就是变量**。类似于我们是用过的替代变量（占位符）。就是在sql语句中使用变量，通过改变变量的值来得到不同的结果。

sql语句是分为动态部分和静态部分的。而动态部分在一般的情况下，对执行计划的影响是微乎其微的。

**同一个sql语句有不同动态部分生成的执行计划是相同的。**

优点：

- 使用动态绑定，可以**减少sql的解析**，从而减少了数据库引擎在sql解析上资源的消耗。
- 提高了**执行效率和可靠性**。减少对数据库的访问实际上就是减少了数据库的工作量

缺点：

- 可能长时间使用动态sql，由于参数的不同。可能sql的**执行效率不同**；
- **使用不当会有安全问题 sql注入**

### **实现数据安全性控制的常用方法和技术**

数据库管理系统提供的安全措施主要包括

- 用户**身份鉴别**
- 自主存取控制 Discretionary Access Control 
- 强制存取控制 Mandatory Access Control
- **视图**机制
- **审计**
- 数据**加密**存储和加密传输等

### **登记日志的原则（运行记录优先原则）是什么，为什么** 

**运行记录优先原则**:

1. **登记的次序严格按并发事务执行的时间次序**
2. 必须**先写日志文件，后写数据库**

如果先写了数据库修改，而在运行记录中没有登记下这个修改，则以后就**无法恢复这个修改**了。

如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次**不必要的UNDO操作**，并**不会影响数据库的正确性**。

所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。这就是**“先写日志文件”的原则**

### SQL 语句的执行过程，并简单对各个步骤的所花费的代价大小进行描述和比较。

1. 语法分析：确保语句的正确性和有效性。代价很小，语法分析器已预先定义了所有合法的 SQL 语法。
2. 语义分析：需要检查语句中的**对象是否存在**、**用户是否有访问权限**等信息。代价比语法分析高一些。
3. 解析（软解析和硬解析）：将 SQL 语句转换成执行计划，比语义分析高。需要进行语法转换、查询优化等复杂操作。
   1. 在软解析过程中，DBMS 会查找已经编译好的执行计划缓存，如果找到了对应的执行计划就直接使用.
   2. 否则会进行硬解析，生成新的执行计划，此时代价最大。
   3. 执行计划生成：生成最优的执行计划，以最小化查询的代价。代价最高，需要进行大量的计算和查询优化。
4. 查询执行：按照执行计划执行查询，并从磁盘中读取数据、对数据进行排序、过滤和聚合等操作，可能还需要进行大量的磁盘和内存交换。代价取决于查询本身的复杂度以及所涉及的数据量。

综合来看，SQL 语句的执行过程中，查询优化和查询执行往往是代价最大的两个步骤。在实际应用中，可以通过**优化查询语句的结构**、**创建合适的索引**、**优化查询计划**等手段来提高查询性能，从而减少查询优化和查询执行所需的代价。



### **SQL 优化原理是什么？优化的逻辑是怎样的？对此经验之谈**

SQL 优化的原理：

- 通过**优化查询的执行计划**
- **减少查询的时间和资源消耗**
- 提高数据库系统的**性能**。

SQL 优化的逻辑一般可以分为以下几个步骤：

1. 优化**查询语句**：对查询语句进行优化，包括**重写查询语句**、**使用索引**、**避免全表扫描**等。
2. 优化**数据库结构**：根据业务需求优化数据库中表的**结构、索引、分区**等，以提高查询和更新操作的性能。
3. 优化**硬件环境**：优化数据库所在的硬件环境，包括 CPU、内存、磁盘、网络等，以提高数据库系统的整体性能。

对于 SQL 优化的经验之谈，以下是一些常见的建议：

1. 将**过滤条件进行排序**,好的过滤条件先做
2. 使用**join来暗示表连接顺序**，当有多表连接操作时，考虑使用**exists和in操作来优化**
3. **避免过度连接表**，将多维度的查询进行降维处理，一次连接的表不要超过3张，超过就将非关联子查询变成内嵌视图。
   - 聚合子查询转化为JOIN
   - 非关联子查询变成内嵌视图
4. **避免在高层使用distinct**，用exists和in来处理
5. **避免在高层使用select ***, 这样会产生**冗余的结果集，降低性能**
6. **不要滥用子查询**. 子查询有如下好处,除这些好处外,不要用
   1. 分辨过滤条件的好坏
   2. 避免顶层的distinct

总之，SQL 优化需要根据具体的情况进行分析和优化，需要综合考虑查询的复杂度、数据的规模和类型、硬件环境等因素。

### **SQL有什么优化策略，从硬件、系统、应用上分析**

这个优化法则归纳为5个层次：

- 减少数据访问（**减少磁盘访问**）系统上
  - 正确使用**索引**
  - **优化执行计划**
  - 尽量使用**自带函数**,慎用自定义函数.
- 减少服务器CPU开销（**减少CPU**及内存开销）
  - 使用**绑定变量**
  - 合理使用**排序**
  - 减少**模糊查找**
- 返回**更少数据**（减少网络传输或磁盘访问）应用上
  - 数据**分页**处理
  - 返回**只需要的字段**
- 减少交互次数（减少网络传输）应用上
  - 一次连接批量处理数据
  - 使用存储过程.
- 利用更多资源（硬件上）
  - 扩大内存
  - 增加CPU
  - 更快的硬盘
  - 更高速的网络



### **请描述Oracle中IOT的物理存储结构和读取数据的方式，并与堆文件的物理存储结构和读取数据的方式进行比较后解释IOT的适用范围。**

IOT（**Index-Organized** Table）索引组织表 是一种基于B+树的索引类型，它的索引键包括表的主键和数据列。IOT的数据访问和索引访问是一体化的。

IOT通常用于**需要频繁地使用主键查询**的表，因为IOT将主键值和对应的数据行存储在同一个B+树节点中，可以减少磁盘I/O操作的次数，从而提高查询性能。

与堆文件的存储结构相比。

- 堆文件的存储是**随机存储**的，而IOT使用的B树结构是**根据主键按照一定顺序存储**的。
- 堆文件的读取是需要**遍历整个堆文件数据**的，而IOT则可以**通过主键的信息**快速定位到相关节点，读取数据。

IOT适用范围：

- **主键很少更新**。因为主键更新会导致B树结构的重新调整。
- **多用主键查询**。因为IOT是以主键为节点构造B树的，以主键信息查询能较快找到对应节点。
- **很少插入新数据**。插入新数据会导致B树重新调整。
- 希望数据已某种特定的**顺序物理存储**，那也适合用IOT

**IOT的优点**

- **记录排序**，查询效率贼强
- **节约磁盘空间开销**，主键没有空间开销，索引就是数据


**IOT缺点**

- **插入效率也许低于堆文件**

- 对于**经常更新的表不适合用IOT**，因为维护的索引代价大，更何况是多字段索引

## 分库分表

分库 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。
分表 就是将数据库中的数据分散到不同的表上，可以垂直分表，也可以水平分表。

### 分区的作用与类型

**分区的作用**: 提高**并发性和并行性**，从而增强系统架构的**可伸缩性**

**分区的类型**（不一定是方式）

循环分区：**不受数据影响**的内部机制。分区定义为各个磁盘的存储区域；可以看作是随意散布数据的机制；保持更改带来的磁盘I/O操作的平衡 

数据驱动分区：根据**一个或多个字段中的值(分区键)**来定义分区。是一种手工分区，一般叫分区视图.

### **数据驱动分区的实现方式**

**哈希分区(Hash-partitioning)**

- 对**分区键进行哈希运算**，根据运算结果进行分区.
- 能保证**根据分区键可以快速找到记录**，但对范围搜索没有任何帮助。
- 其实更接近与循环分区, 只是它还能**负载均衡提高并发**的能力. 

**范围分区(Range- partitioning)**

- 滑动窗口，就是范围分区，**根据连续数据的范围**对数据进行分区。
- **非常适合处理历史数据**，每一个分区专门用来存储**特定范围内的数据**。
- 一般系统还会设定**else分区**,来存储所有**可能漏网的数据**(其他)
- 应用: 时间范围, 字母范围

**列表分区(List-partitioning)**

- 是一种最具手工风格的分区类型，适合**定制某种特殊的解决方案**。
- **分区键必须明确指定**，但**分区键只能有一列**，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的**单个分区对应值可以是多个**。

- 一旦插入的列值不在分区范围内，则插入/更新就会失败.
- 因此
  通常建议使用列表分区时，要创建一个**default分区**存储那些**不在指定列表内的记录**。

**复合分区**:

- 很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。

- 一种二位分区处理的方法，比如在时间的分区中，建立哈希分区,范围-哈希分区、范围-列表分区等
- **OB把它叫做二级分区**，再举个例子，**类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区**。

数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候**数据分区最具有开发使用的价值**。

### **分区是如何提高查询效率**

分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件上），利于高速检索，**查询数据时，不至于每次都扫描整张表**.

### **分区的优点和缺点**

**优点**：

- 增强**可用性**：如果表的某个分区出现故障，表在其他分区的数据仍然可用；
- **维护**方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；
- **均衡I/O**：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能；
- 改善**查询性能**：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。

**缺点**：

- 除了堆文件之外的任何存储方法，都会**带来复杂性**
- **选错存储方式**会带来大幅度的性能降低
- 降低了并发个数，但如果**涉及数据量非常庞大**，**降低并发所带来的缺陷远远小于分区所带来的性能提高**
- 由于**强制的部分数据聚合**可能会**导致其他数据的分散**，所以不同的查询请求也可能会形成性能上的矛盾

### **数据分区的最佳方法**

- 当**数据分区键均匀分布时**，分区表查询收益最大
- **避免更新分区键**, 更新分区键会影响数据移动
- **不在更新数据频繁时使用分区**.
- **考虑整体**,当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个

