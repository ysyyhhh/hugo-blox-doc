# Linux


#### 五种IO模型

1. 阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。
2. 非阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。
3. I/O复用模型：应用程序使用select、poll或epoll等系统调用来监控多个文件描述符，当有数据准备好时，应用程序会被通知。
   1. I/O 多路复用内部需要使用非阻塞 I/O
4. 信号驱动式I/O模型：应用程序使用sigaction系统调用来注册一个信号处理函数，当数据准备好时，内核会向应用程序发送一个信号，应用程序在信号处理函数中处理数据。
5. 异步I/O模型：应用程序调用aio_read或aio_write等异步I/O函数来发起I/O操作，内核会在I/O操作完成后通知应用程序。

#### 解释同步，阻塞

同步是指应用程序在执行某个操作时，必须等待该操作完成后才能继续执行下一步操作。

阻塞是指应用程序在执行某个操作时，如果该操作不能立即完成，应用程序会被挂起，直到该操作完成为止。

在阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止，这就是阻塞。而在非阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，这就是非阻塞。


#### NIO和BIO区别

BIO（Blocking I/O）是阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。NIO（Non-blocking I/O）是非阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。

#### NIO的底层

NIO的底层实现主要包括以下几个部分：

1. 缓冲区：NIO使用缓冲区来存储数据，包括读缓冲区和写缓冲区。
2. 通道：NIO使用通道来进行数据的读写操作，通道类似于流，但是可以双向传输数据。
3. 选择器：NIO使用选择器来监控多个通道的状态，当有数据准备好时，选择器会通知应用程序。


### I/O 多路复用

阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用**多线程来处理多个文件描述符**。

多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在**一个线程里轮询多个文件描述符是否就绪**。

但是非阻塞 I/O 的缺点是：**每次发起系统调用，只能检查一个文件描述符**是否就绪。当文件描述符很多时，系统调用的成本很高。

因此引入了 I/O 多路复用，可以通过一次系统调用，检查多个文件描述符的状态。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回。I/O 多路复用内部使用非阻塞 I/O 检查每个描述符的就绪状态。

如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。

I/O 多路复用引入了一些额外的操作和开销，性能更差。

但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。

#### 文件描述符 fd

文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。

系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而文件描述符实际上就是这张表的索引。当进程打开（open）或者新建（create）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。

一般来说，每个进程最多可以打开 64 个文件，fd ∈ 0~63。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。

每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。

#### socket与fd的关系

socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 socket() 函数创建：

int socket(int domain, int type, int protocol)
**返回的就是这个 socket 对应的文件描述符 fd**。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。

可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。

**socket 与 fd 是一一对应的**。

通过 socket 通信，实际上就是通过文件描述符 fd 读写文件。

这也符合 Unix“一切皆文件”的哲学。

在下面的场景下，socket 和 fd 可以视为同义词


I/O 多路复用内部会遍历集合中的每个文件描述符，判断其是否就绪：

for fd in read_set
    if（ readable(fd) ) // 判断 fd 是否就绪
        count++
        FDSET(fd, &res_rset) // 将 fd 添加到就绪集合中
        break
...
return count
这里的 readable(fd) 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 fd 未就绪时，select 会阻塞在这个文件描述符上，无法检查下个文件描述符。

注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，


#### select poll epoll

select、poll和epoll都是Linux下的I/O多路复用机制，用于监控多个文件描述符，当有数据准备好时，通知应用程序。select和poll是最早的I/O多路复用机制，epoll是Linux内核提供的一种高效的I/O多路复用机制。


select：select是最早的I/O多路复用机制，它使用一个fd_set结构体来存储所有需要监控的文件描述符，当有数据准备好时，select会返回，应用程序可以通过遍历fd_set结构体来找到数据准备好的文件描述符。

poll：poll是select的改进版，它使用一个pollfd结构体来存储所有需要监控的文件描述符，当有数据准备好时，poll会返回，应用程序可以通过遍历pollfd结构体来找到数据准备好的文件描述符。

与select相比，poll的主要优点是可以监控的文件描述符数量更多，但是poll的效率并没有提高。

epoll：epoll是Linux内核提供的一种高效的I/O多路复用机制，它使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。与select和poll相比，epoll的主要优点是效率更高，可以监控的文件描述符数量更多。


简而言之，epoll 有以下几个特点：

使用红黑树存储文件描述符集合
使用队列存储就绪的文件描述符
每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态
select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。

#### select

```C++
int select(int nfds,
            fd_set *restrict readfds,
            fd_set *restrict writefds,
            fd_set *restrict errorfds,
            struct timeval *restrict timeout);
```

readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。

timeout 参数表示调用 select 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞


fd_set 文件描述符集合

由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。

**比如设 fd_set 长度为 1 字节**，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set = 00010011 时，表示文件描述符 1、2、5 已经就绪。

select 的缺点是：
- 性能开销大
  - 每次调用 select 都需要将 fd_set 集合从用户态拷贝到内核.
  - select 会遍历所有文件描述符，即使只有少数文件描述符就绪，也会遍历所有文件描述符。
- 文件描述符数量有限
  - select 的 fd_set 集合是一个位图，**位图的大小是固定的**，因此 select 能够监控的文件描述符数量有限。
  - 一般来说，select 最多只能监控 1024 个文件描述符。


#### poll

```C++
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
```

poll 在用户态通过数组方式传递文件描述符，在内核会转为链表方式存储，没有最大数量的限制.

性能开销上和 select 类似，都需要将文件描述符集合从用户态拷贝到内核态。但是 poll 的效率并没有提高，因为 poll 仍然需要遍历所有文件描述符。


#### epoll

epoll需要使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。

```C++
int epoll_create(int size);

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

epoll_create 创建一个 epoll 实例，返回一个文件描述符，用于操作 epoll 实例。

epoll_ctl 用于向 epoll 实例中添加、修改或删除文件描述符。

epoll_wait 用于等待文件描述符就绪,是主要函数,功能相当于 select 和 poll 的功能。

epoll 的特点：
- epoll 使用红黑树存储文件描述符集合
  - 可以快速查找文件描述符。
- epoll 使用队列存储**就绪的文件描述符**，可以快速找到就绪的文件描述符。
- epoll 只需在添加文件描述符时传入一次，通过事件更改文件描述符状态。


对于“性能开销大”
- epoll_ctl 中为**每个文件描述符指定了回调函数**，并在就绪时将其加入到就绪列表
  - 因此 epoll 不需要像 select 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。



#### epoll底层实现


epoll是Linux内核提供的一种高效的I/O多路复用机制，其底层实现主要包括以下几个部分：

1. 内核事件表：epoll使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。
2. 文件描述符表：epoll使用一个文件描述符表来存储所有需要监控的文件描述符，每个文件描述符都对应一个epoll_event结构体，用于存储该文件描述符上的事件信息。
3. 回调函数：当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。




## 线程

### 协程

协程完全由程序所控制（在用户态执行），带来的好处是性能大幅度的提升。



协程的使用
- 计算型的操作，利.用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。
- IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。


