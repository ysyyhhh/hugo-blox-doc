# Modern C++

## 面向对象

### C++多态

多态分为两种，一种是运行时的多态，一种是编译时的多态。

前者称为动态绑定，后者称为静态绑定。

动态绑定时由虚函数来实现，静态绑定是由函数重载来实现。


## 语法
### lambda表达式

描述:

- 一个匿名函数对象
- 一个可调用的代码单元
- 一个函数对象的语法糖

语法规则:
[](){};  
[]: lambda表达式的引导符
(): 参数列表
{}: 函数体

具体示例

```C++
for (auto &thread: threads) {
 thread = std::thread([&taskId, num_total_tasks, runnable] {
  for (int id = taskId++; id < num_total_tasks; id = taskId++)
   runnable->runTask(id, num_total_tasks);
 });
}
```

在示例中, thread的初始化是一个lambda表达式, 该lambda表达式的参数列表为空, 函数体为

```C++
{
  for (int id = taskId++; id < num_total_tasks; id = taskId++)
   runnable->runTask(id, num_total_tasks);
 }
```

这样一个thread可以负载多个任务.

如果不用lambda表达式, 那么就需要定义一个函数, 然后将函数的地址传递给thread, 这样就会增加代码量.

也就是说实际上 thread的参数可以是一个函数对象, 也可以是一个函数指针, 也可以是一个lambda表达式.

```
explicit
不能在传参时隐式调用构造函数。
```



```C++
使用reset来用子类覆盖父类
auto new_node = new TrieNodeWithValue(std::move(**end_node), value);
end_node->reset(new_node);
```

### 空类包括什么成员

默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符和一个默认析构函数

### 浅拷贝和深拷贝

浅拷贝/值拷贝 数据数量不变，共享同一片空间

深拷贝 开辟一块新的空间存入数据

### 虚函数

虚函数使用的其核心目的是**通过基类访问派生类定义的函数**。

有vptr（虚指针）和vtbl(虚表)

在派生类中重写该虚函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。

抽象类是指包括至少一个纯虚函数的类。

### 虚函数表

虚函数表是在谁身上？对象、类、子类、父类？
A: 虚函数表是在类的对象上的，每个对象都有一个虚函数表指针，指向虚函数表。

### 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）

虚继承
- 虚基类依旧存在继承类中，只占用存储空间
- 虚基类表存储的是虚基类相对直接继承类的偏移
虚函数
- 虚函数不占用存储空间
- 虚函数表存储的是虚函数地址


### 类的大小，子类继承后的影响

1. 非静态成员变量的内存占用之和
2. 考虑内存对其的问题；
3. [虚函数](https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)产生的额外内存开销，即虚函数表指针(Virtual Table Pointer);

空白类被继承后可能会被编译器优化掉

### union 大端小端

union 的赋值（考察大小端以及 union 的内存结构）
联合体变量中的成员是共用一个首地址，共占同一段内存空间，所以在任意时刻只能存放其中一个成员的值。

大端：内存的低地址存数据的高字节
小端：
举例：假如一个int类型数，十六进制(就是给人看的)表示为： 0x0026F800
那么，如果是小端机器，它在内存中就是：00F82600   （上面的低字节还是在低地址）  内存中地址在这种表示法从左往右由低地址到高地址。
   如果是大端机器，它在内存中就是 ：0026F800 (所见即得） （上面的低字节存到了高地址)
大小端是以字节为单位的，因为内存中最小单元就是字节。

## 内存相关

### new 和 malloc

[new malloc](https://blog.csdn.net/weixin_43899008/article/details/123261412)

malloc(100M)一块大小，相应的虚拟内存有多少？ （我说这个不是可以自己设么）

* new是关键字，需要编译器支持；malloc是库函数，需要头文件支持。
* new申请内存无需指定内存大小，编译器会根据类型信息自行计算。除此之外，new会调用构造函数。
* malloc必须由我们计算需要申请的字节数，需要显式指出所需内存的尺寸，并且返回后强行转换为实际类型的指针。而且malloc只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其**值是随机**的。
* new在自由储存区分配内存，malloc在堆上分配内存。

### 悬空指针和野指针

悬空指针是指一个**没有指向任何内存单元**的指针.

使用悬空指针报**段错误**。

```
void *p = malloc(size);
assert(p);
free(p); 
// 现在 p 是“悬空指针”
p = NULL;//// 避免“悬空指针”
```

野指针是指一个不确定其具体指向的指针，最常来自于未初始化的指针。

```
void *p;
// 此时 p 是“野指针”

void *p = NULL;
void *data = malloc(size);
```

因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。

在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：

### 用C++如何保证资源不泄露

遵循RAII原则。

在初始化中获取资源 Resource acquisition is initialation

对象管理自己的资源。

智能指针是RAII原则的体现。

### 内存泄漏

**内存泄露及解决办法**：

**什么是内存泄露？**

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。
- new和malloc申请资源使用后，没有用delete和free释放；
- 子类继承父类时，父类析构函数不是虚函数。
  - 必须是虚函数这样才能触发动态绑定，这样才不会仅调用父类的析构函数
  - 是虚函数会先调用子类的虚构函数，再调用父类的虚构函数
- Windows句柄资源使用后没有释放。


**怎么检测？**

第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：使用**智能指针**。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

### 智能指针 shared_ptr与unique_ptr的开销比较

shared_ptr内部引用计数对象要通过new创建，这样所有的对象才能指向同一个引用计数变量；

unique_ptr接近原生的性能

https://blog.csdn.net/codingcs/article/details/120403980

### 右值引用

右值引用主要用于移动语义和完美转发

#### 移动语义

- 传统的拷贝构造函数和赋值操作符都是通过复制的方式来初始化一个新对象，这样会导致内存的分配和释放，效率较低。
- 移动语义是一种新的语义，它允许将资源从一个对象转移到另一个对象，而不是复制资源。这样可以避免不必要的内存分配和释放，提高程序的效率。

#### 完美转发

完美转发是指在函数模板中保持参数的原有类型，不改变参数的类型，将参数原封不动地传递给其他函数。

### 如果有多个重载函数，那么我根据函数名打断点，GDB会怎么执行呢，是只执行一个还是全部都显示出来（都显示出来）

## STL

### vector

可变长数组，用倍增的思想。

vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度

2倍 gcc

1.5倍 vs2019

以2倍的方式扩容，导致**下一次申请的内存必然大于之前分配内存的总和**，导致**之前分配的内存不能再被使用**，所以最好倍增长因子设置为(1,2)之间.

### map

map底层红黑树

unordered_map底层哈希

### bitset

二进制数组，bool类型的数组。

可以加速到/64

### 迭代器失效的情况，以及解决方法

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，**erase返回下一个有效的迭代器**。
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以**在调用erase之前，记录下一个元素的迭代器**即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

### 哈希冲突的解决方法

开放地址法/再散列法

* 冲突时采用
* 线性探查
* 二次探测
* 伪随机

链表法/拉链法

* 冲突时直接单链表

再哈希法

* 输出是同一个位置就再次哈希（第二个哈希函数）
