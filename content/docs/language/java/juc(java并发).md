# Java 多线程

## 线程与进程

一个Java程序的运行是一个进程，包括一个main线程和多个其他线程

Java的线程和操作系统的线程的区别
- JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程

用户级线程和内核级线程的区别
- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。

线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：

- 一对一（一个用户线程对应一个内核线程）
- 多对一（多个用户线程映射到一个内核线程）
- 多对多（多个用户线程映射到多个内核线程）

Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。

JDK21正式引入了虚拟线程


![](img/JUC(Java并发)/Java线程结构.png)


### 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？

程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。

程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。

虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）

本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。

为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。




### 为什么堆和方法区是线程共享的呢？

堆：是进程中所有线程共享的内存区域，用于存放对象实例。

方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。



### 并发并行、同步异步

并发：指多个线程交替执行，从宏观上看是同时执行的。

并行：指多个线程同时执行，从微观上看是同时执行的。

同步：指多个线程按照一定的顺序执行。

异步：指多个线程按照不确定的顺序执行。

## 多线程

### 为什么要使用多线程？

多线程的主要优点有以下几点：
- 线程间的切换开销小
- 多线程高并发是高并发量的基础
- 现在的CPU都是多核的，多线程可以充分利用CPU的性能

### 多线程带来的问题？

多线程的主要问题有以下几点：
- 线程安全问题
- 死锁问题
- 内存泄漏问题


线程安全：
- 线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。

死锁：
- 死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。

内存泄漏：
- 内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。

### 单核上的多线程效率

单核上的多线程效率，取决于线程的类型

- CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。
- IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。

### 多线程的实现方式

Java中实现多线程主要有两种方式：

1. 继承Thread类并重写run()方法。
2. 实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。

严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。

## 线程的生命周期和状态

线程的生命周期主要包括以下几个状态：
- 新建状态（New）：线程对象被创建后的状态。
- 就绪状态（Waiting）：线程对象调用start()方法后的状态。
- 运行状态（Running）：线程对象调用run()方法后的状态。
- 阻塞状态（Blocked）：线程对象调用sleep()、wait()、join()等方法后的状态。
- 死亡状态（Terminated）：线程对象执行完run()方法后的状态。

![](img/JUC(Java并发)/Java线程状态变化.png)

### 上下文切换

上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。

发生上下文切换的原因主要有以下几点：
- 时间片耗尽
- 调用阻塞类型的中断，如请求IO、sleep、wait、join等
- 被终止

上下文切换的开销主要包括以下几个方面：
- 保存和恢复寄存器
- 保存和恢复程序计数器
- 保存和恢复内存映射表

### 线程死锁



线程池

线程池的使用

1个10G大小文件，如何得前100个最大数字


## 线程

#### Java创建线程的方法

Java中创建线程的方法主要有两种：

1. 继承Thread类并重写run()方法。
2. 实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。

#### 查看线程的执行结果，怎么拿到

可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。

另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过Thread对象的get()方法获取返回值。

#### 有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你

Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。

虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。

#### 阻塞队列有哪些

Java中提供了多种阻塞队列实现，包括ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。这些阻塞队列实现都是线程安全的，可以在多线程环境下使用。

#### 线程池的工作流程

线程池的工作流程如下：

1. 当有任务需要执行时，线程池会从线程池中获取一个空闲线程来执行任务。
2. 如果线程池中没有空闲线程，则会根据线程池的配置创建新的线程来执行任务。
3. 当任务执行完毕后，线程会返回线程池，并等待下一次任务的分配。

#### 线程池拒绝策略有哪些

线程池的拒绝策略主要有以下几种：

1. AbortPolicy：直接抛出RejectedExecutionException异常。
2. CallerRunsPolicy：将任务交给调用线程来执行。
3. DiscardPolicy：直接丢弃任务，不做任何处理。
4. DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交任务。

#### 线程池的参数有哪些

线程池的参数主要包括以下几个：

1. corePoolSize：核心线程数，即线程池中保留的线程数。
2. maximumPoolSize：最大线程数，即线程池中允许的最大线程数。
3. keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。
4. unit：时间单位，用于指定keepAliveTime的时间单位。
5. workQueue：任务队列，用于存储等待执行的任务。
6. threadFactory：线程工厂，用于创建新的线程。
7. handler：拒绝策略，用于处理无法处理的任务。
