# Java 多线程

## 线程与进程

一个Java程序的运行是一个进程，包括一个main线程和多个其他线程

Java的线程和操作系统的线程的区别
- JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程

用户级线程和内核级线程的区别
- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。

线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：
- 一对一（一个用户线程对应一个内核线程）
- 多对一（多个用户线程映射到一个内核线程）
- 多对多（多个用户线程映射到多个内核线程）

Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。

JDK21正式引入了虚拟线程


![](img/JUC(Java并发)/Java线程结构.png)


### 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？

程序计数器的功能：
- 记录当前线程执行的字节码指令的地址，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。


虚拟机栈
- 每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）

本地方法栈
- 用于支持本地方法调用，即调用C/C++编写的本地方法。

为了保证**线程的局部变量不被其他线程访问**，虚拟机栈和本地方法栈是线程私有的。

### 为什么堆和方法区是线程共享的呢？

堆：是进程中所有线程共享的内存区域，用于存放对象实例。

方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。

堆和方法区是线程共享的，是为了**方便线程之间共享数据**。

### 并发并行、同步异步

并发：指多个线程交替执行，从宏观上看是同时执行的。

并行：指多个线程同时执行，从微观上看是同时执行的。

同步：指多个线程按照一定的顺序执行。

异步：指多个线程按照不确定的顺序执行。

## 多线程

### 为什么要使用多线程？

多线程的主要优点有以下几点：
- 线程间的切换开销小
- 多线程高并发是高并发量的基础
- 现在的CPU都是多核的，多线程可以充分利用CPU的性能

### 多线程带来的问题？

多线程的主要问题有以下几点：
- 线程安全问题
- 死锁问题
- 内存泄漏问题


线程安全：
- 线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。

死锁：
- 死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。
- 四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件

内存泄漏：
- 内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。

### 单核上的多线程效率

单核上的多线程效率，取决于线程的类型

- CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。
- IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。

### 多线程的实现方式

Java中实现多线程主要有两种方式：

1. 继承Thread类并重写run()方法。
2. 实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。

严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。

### 查看线程的执行结果，怎么拿到

可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。

另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过Thread对象的get()方法获取返回值。


## 线程的生命周期和状态

线程的生命周期主要包括以下几个状态：
- 新建状态（New）：线程对象被创建后的状态。
- 运行状态（Runable）：线程对象调用run()方法后的状态。
- 就绪状态（Waiting）：线程对象调用start()方法后的状态。
- 阻塞状态（Blocked）：线程对象调用sleep()、wait()、join()等方法后的状态。
- 死亡状态（Terminated）：线程对象执行完run()方法后的状态。

![](img/JUC(Java并发)/Java线程状态变化.png)



### 上下文切换

上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。

发生上下文切换的原因主要有以下几点：
- 时间片耗尽
- 调用阻塞类型的中断，如请求IO、sleep、wait、join等
- 被终止

上下文切换的开销主要包括以下几个方面：
- 保存和恢复寄存器
- 保存和恢复程序计数器
- 保存和恢复内存映射表

### 线程死锁
四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件



#### 预防和避免

预防死锁是破坏死锁的后三个条件。
- 破坏请求与保持条件：一次性申请所有资源。
- 破坏不剥夺条件：如果一个线程申请不到资源，就释放已经占有的资源。
- 破坏循环等待条件：按序申请资源。

避免死锁是通过银行家算法来实现的。
- 银行家算法是一种避免死锁的算法，它通过判断系统是否处于安全状态来避免死锁。
- 银行家算法的核心思想是：当一个进程申请资源时，系统会先判断该进程申请资源后系统是否处于安全状态，如果是则分配资源，否则等待。


### sleep()方法和wait()方法

- sleep()方法
  - Thread类的静态方法，可以让当前线程休眠一段时间
  - 不会释放锁。
  - 用于暂停执行
- wait()方法
  - Object类的方法，可以让当前线程等待
  - 会释放锁。
  - wait()调用后, 线程不会自动唤醒, 需要调用notify()或notifyAll()方法唤醒。
    - 或者使用wait(long timeout)方法，指定等待时间后自动唤醒。
  - 用于线程间的通信


#### 为什么wait()不定义在Thread类中呢？

wait()方法是Object类的方法，是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。

每个Object都有对象锁，因此定义在Object类中。

#### 为什么sleep()不定义在Object类中呢？

sleep()方法是Thread类的静态方法，是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。


### 可以直接调用run()方法吗？

可以直接调用run()方法，但是这样会导致run()方法在当前线程（main线程）中执行，不会创建新的线程。

正常情况是调用start()方法，然后由JVM来创建新的线程并执行run()方法。

调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。





## JMM

JMM是Java内存模型的缩写，是一种抽象的概念，用于描述Java程序中的内存访问规则。

定义了一个线程之间如何通过内存进行通信的规范，即线程之间如何访问共享内存。

JMM是Java解决多线程并发问题的核心，它定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。

### 并发问题的原因

CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，同时导致了并发问题。


- CPU 增加了缓存，以均衡与内存的速度差异.
  - 导致可见性问题
  - 可见性是指当多个线程访问共享变量时，一个线程修改了共享变量的值，其他线程**能够看到修改后的值。**
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
  - 导致原子性问题
  - 原子性: 是指一个操作是不可中断的，要么全部执行成功，要么全部不执行。
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题

#### 可见性问题

可见性问题,就是看不到修改后的值, 由CPU缓存导致.

```java

//线程1执行
int a = 0;//1
a = 10;//2

//线程2执行
int j = a//3
```

假设,有两个CPU, CPU1执行线程1, CPU2执行线程2.
线程1执行语句2时, 会先把a=0这个初始值从主内存中加载到CPU1的高速缓存中, 然后在CPU1的高速缓存中赋值a=10, 并没有立即写入到主存.

线程2 如果在 线程1写入主存之前,执行了语句3, 那么就会读取到a=0这个初始值, 而不是修改后的值10.

#### 原子性问题

原子性问题由分时复用CPU导致.


Java中只有对基本数据类型的**读取和赋值**操作是原子性的，其他的操作都不是原子性的。
下面语句1是原子性的, 其他都不是原子性的.
```java
x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x = x + 1;     //语句4： 同语句3
```

因此在执行一些常见,但不是原子性的操作时,会导致原子性问题.

```Java
int i = 1;

// 线程1执行
i += 1;

// 线程2执行
i += 1;
```

i += 1需要三条 CPU 指令

1. 将变量 i 从内存读取到 CPU寄存器；
2. 在CPU寄存器中执行 i + 1 操作；
3. 将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

如果线程1执行完1后, 轮到线程2执行三条指令, 线程1再执行2,3. 会导致






### CPU缓存模型

CPU缓存模型主要包括以下几种：





线程池

线程池的使用

1个10G大小文件，如何得前100个最大数字






## 锁

volatile关键字
保证了变量的可见性，但是不保证原子性。

synchornized关键字
保证了变量的可见性和原子性，但是会导致线程阻塞。

如何禁止指令重排


### 乐观锁与悲观锁

### synchronized关键字

### ReentrantLock

### ReentrantReadWriteLock

### Atomic 原子类





## 线程池


### ThreadLocal


### 线程池


### Future

### AQS


#### 有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你

Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。

虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。

#### 阻塞队列有哪些

Java中提供了多种阻塞队列实现，包括ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。这些阻塞队列实现都是线程安全的，可以在多线程环境下使用。

#### 线程池的工作流程

线程池的工作流程如下：

1. 当有任务需要执行时，线程池会从线程池中获取一个空闲线程来执行任务。
2. 如果线程池中没有空闲线程，则会根据线程池的配置创建新的线程来执行任务。
3. 当任务执行完毕后，线程会返回线程池，并等待下一次任务的分配。

#### 线程池拒绝策略有哪些

线程池的拒绝策略主要有以下几种：

1. AbortPolicy：直接抛出RejectedExecutionException异常。
2. CallerRunsPolicy：将任务交给调用线程来执行。
3. DiscardPolicy：直接丢弃任务，不做任何处理。
4. DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交任务。

#### 线程池的参数有哪些

线程池的参数主要包括以下几个：

1. corePoolSize：核心线程数，即线程池中保留的线程数。
2. maximumPoolSize：最大线程数，即线程池中允许的最大线程数。
3. keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。
4. unit：时间单位，用于指定keepAliveTime的时间单位。
5. workQueue：任务队列，用于存储等待执行的任务。
6. threadFactory：线程工厂，用于创建新的线程。
7. handler：拒绝策略，用于处理无法处理的任务。
