# JVM

![](img/JVM/系统结构.png)

## TODO:类字节码

JVM上运行的是字节码，而不是源代码。
字节码是一种中间代码，它是一种介于源代码和机器码之间的代码。字节码是由Java编译器编译生成的，它是一种与平台无关的代码，可以在任何支持Java虚拟机的平台上运行。

JVM不仅支持Java语言，还支持其他语言，如Groovy、Kotlin、Scala等。这些语言都可以编译成字节码，然后在JVM上运行。


### 字节码文件

字节码文件是以.class为扩展名的文件，它包含了Java源代码编译生成的字节码。
字节码文件是一种二进制文件以8位字节为单位存储的，它包含了类的结构信息、字段信息、方法信息、接口信息等。

class文件采用伪结构来存储, 有两种类型: 无符号数和表。

无符号数: 占两个字节, 用于描述数字, 例如: u1, u2, u4, u8

表: 由多个无符号数或其他表构成, 用于描述有层次关系的复合结构, 例如: 字段表, 方法表, 属性表

![](img/JVM/class文件结构.png)

### 字节码增强技术

字节码增强技术是指在编译后的字节码文件中插入新的字节码，从而增强程序的功能。字节码增强技术可以用于实现AOP（Aspect-Oriented Programming）编程、动态代理、代码注入等功能。



## 类加载机制

### 类的生命周期

类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。

类加载的过程包括了: 加载、验证、准备、解析、初始化。

其中解析的过程是可选的，可以在初始化阶段之后再进行。
- 为了支持动态绑定

其余阶段按顺序开始,但是不一定按顺序结束.

### 类的加载

类的加载是指将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。

在加载阶段,虚拟机需要完成:
- 通过类的全限定名获取类的二进制字节流
- 将字节流代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口

![](img/JVM/类的加载.png)

类加载器不需要等到"首次使用"时才加载类,而是在预料到类会被使用时就加载类. 如果在加载类的过程中遇到了错误,类加载器必须抛出异常,通知调用者类加载失败.

加载class文件的方式:
- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip,jar等归档文件中加载
- 从数据库中读取.class文件
- 将Java源文件动态编译为.class文件

### 连接

连接阶段包括了验证、准备和解析。

#### 验证

验证是确保加载的类符合JVM规范的过程。验证阶段的目的是确保被加载的类是合法、合理的，不会危害虚拟机的安全。

验证阶段主要包括了四个方面的验证：
- 文件格式验证：验证字节码文件是否符合JVM规范。
- 元数据验证：验证字节码文件中的类、字段、方法等信息是否符合JVM规范。
- 字节码验证：验证字节码文件中的字节码是否符合JVM规范。
- 符号引用验证：验证字节码文件中的符号引用是否符合JVM规范。

#### 准备

准备阶段是为类的**静态变量分配内存并设置初始值**的过程。这些变量所使用的内存都将在方法区中进行分配.
- 不包括实例变量,实例变量会在对象实例化时随着对象一起分配在Java堆中
- 初始值是默认的零值,例如: 0, null

#### 解析

解析阶段是将**常量池中的符号引用替换为直接引用**的过程。

解析阶段是可选的，可以在初始化阶段之后再进行。

解析针对类或接口,字段,类方法,接口方法,方法类型,方法句柄,方法调用点限定符,动态调用点限定符这几类符号引用进行.

符号引用包含了被引用项的名称、描述符以及其所在的类或接口的名称等信息. 但没有直接指向目标的指针, 为了使得方法调用可以实现动态连接,Java编译器会在Class文件中的常量池中留下一些符号引用,以便在运行期间将其解析为直接引用.


### 初始化

初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

<!-- 
初始化是为类的静态变量赋予正确的初始值的过程。

对类变量进行初始值设定有两种方式:
- 声明变量时指定初始值
- 使用静态初始化块

JVM初始化步骤
- 如果这个类还没有被加载和连接,则先进行加载和连接
- 如果类的直接父类还没有被初始化,则先初始化其直接父类
- 如果类中有初始化语句,则依次执行这些初始化语句

类的初始化动机: 只有对类的主动使用才会导致类的初始化,主动使用包括:
- 创建类的实例, new
- 访问类的静态变量,或者为静态变量赋值
- 调用类的静态方法
- 反射,例如: Class.forName("com.example.Test")
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类,即main方法所在的类

类初始化的方式
- 构造函数
- 静态代码块 -->

### 使用

类访问方法区的数据,执行程序代码,调用方法等.

对象是在堆中分配的,对象的实例变量也在堆中分配,但是对象的引用是在栈中分配的.

### 卸载

JVM结束声明周期的情况:
- 执行了System.exit()方法
- 程序正常结束
- 程序异常结束
- 由于操作系统错误导致JVM进程终止

### 类加载器

类加载器是用于加载类的对象，它负责将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。

分为三种:
- **启动类**加载器: Bootstrap ClassLoader
  - 负责加载JRE/lib下, 或 -Xbootclasspath选项指定的路径中的核心类库
  - 由C++实现,不是Java类
- **扩展类**加载器: Extension ClassLoader
  - 负责加载JRE/lib/ext目录下的扩展类库,如javax.*开头的类
  - 由Java实现,是sun.misc.Launcher$ExtClassLoader类
  - 开发者可以直接使用扩展类加载器
- **应用程序类**加载器: Application ClassLoader
  - 负责加载用户类路径上的类库
  - 由Java实现,是sun.misc.Launcher$AppClassLoader类
  - 开发者可以直接使用应用程序类加载器

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器
因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:
- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java class，例如数据库中和网络中。


#### 寻找类加载器

类加载器的寻找顺序是: 启动类加载器 -> 扩展类加载器 -> 应用程序类加载器

```java
package com.pdai.jvm.classloader;
public class ClassLoaderTest {
     public static void main(String[] args) {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        System.out.println(loader);
        System.out.println(loader.getParent());
        System.out.println(loader.getParent().getParent());
    }
}
```

### 类的加载

类的加载有三种方式:
- 命令行启动应用时候由JVM初始化加载
- 通过Class.forName()方法动态加载
- 通过ClassLoader.loadClass()方法动态加载

### JVM类加载机制

JVM类加载机制是指JVM在加载类的过程中所采取的策略和步骤。

全盘负责: 一个类加载器负责加载一个类,如果一个类加载器加载了一个类,那么这个类所依赖的和引用的类也由这个类加载器负责加载.

父类委托: 一个类加载器在加载类时,先委托给其父类加载器加载,如果父类加载器无法加载,则自己加载.

缓存机制: 保证所有加载过的类都会被缓存,当程序中需要使用某个类时,类加载器会先从缓存中搜索这个类,只有当缓存中不存在这个类时,类加载器才会去加载这个类.

### 类加载器的双亲委派模型

双亲委派模型是指类加载器在加载类时，会先委托给其父类加载器加载，只有在父类加载器无法加载时，才会自己加载。

1. 当AppClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给父类加载器ExtClassLoader去完成
2. 当ExtClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给BootstrapClassLoader去完成
3. 如果BootstrapClassLoader加载失败(在rt.jar中找不到所需类),会把类加载请求委派给ExtClassLoader
4. 如果ExtClassLoader加载失败(在jre/lib/ext中找不到所需类),会把类加载请求委派给AppClassLoader
5. 如果AppClassLoader加载失败(在用户类路径下找不到所需类),会抛出ClassNotFoundException

```java
public Class<?> loadClass(String name)throws ClassNotFoundException {
            return loadClass(name, false);
    }
    protected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {
            // 首先判断该类型是否已经被加载
            Class c = findLoadedClass(name);
            if (c == null) {
                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
                try {
                    if (parent != null) {
                         //如果存在父类加载器，就委派给父类加载器加载
                        c = parent.loadClass(name, false);
                    } else {
                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
                        c = findBootstrapClass0(name);
                    }
                } catch (ClassNotFoundException e) {
                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
```

优势:
- 避免类的重复加载, 防止内存中出现多份同样的字节码
- 保护程序安全, 防止核心API被随意篡改

### 自定义类加载器

```java
package com.pdai.jvm.classloader;
import java.io.*;

public class MyClassLoader extends ClassLoader {

    private String root;

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = loadClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] loadClassData(String className) {
        String fileName = root + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
        try {
            InputStream ins = new FileInputStream(fileName);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 1024;
            byte[] buffer = new byte[bufferSize];
            int length = 0;
            while ((length = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String getRoot() {
        return root;
    }

    public void setRoot(String root) {
        this.root = root;
    }

    public static void main(String[] args)  {

        MyClassLoader classLoader = new MyClassLoader();
        classLoader.setRoot("D:\\temp");

        Class<?> testClass = null;
        try {
            testClass = classLoader.loadClass("com.pdai.jvm.classloader.Test2");
            Object object = testClass.newInstance();
            System.out.println(object.getClass().getClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```

自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。

这里有几点需要注意 :
1、这里传递的文件名需要是类的全限定性名称，即com.pdai.jvm.classloader.Test2格式的，因为 defineClass 方法是按这种格式进行处理的。
2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。
3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。


## Java 内存区域

![](img/JVM/运行时数据区.png)

线程私有的：
- **程序计数器**
- **虚拟机栈**
- **本地方法栈**

线程共享的：
- **堆**
- **方法区**
- 直接内存 (非运行时数据区的一部分)

Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。

虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。

程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。

程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。

虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）

本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。

为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。

### 程序计数器

程序计数寄存器（Program Counter Register）
JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。

是一块较小的内存空间，它可以看作是**当前线程所执行的字节码的行号指示器**。

#### 作用

- 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是线程私有的，每个线程都有一个独立的程序计数器,生命周期与线程的生命周期一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。
  - 如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域

### Java虚拟机栈

Java虚拟机栈内部保存一个个栈帧(Stack Frame),每个栈帧对应一个被调用的方法,每个栈帧包含了局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接(Dynamic Linking)、方法返回地址和一些额外的附加信息。

作用: 主管Java方法的运行，它保存方法的局部变量（8种基本数据类型、对象引用）、部分中间运算结果，并参与方法的调用和返回。

特点
- 快速有效的分配存储方式, 访问速度快(仅次于程序计数器)
- JVM对虚拟机栈的操作只有两种: 
  - 每个方法执行时,创建一个栈帧; 
  - 每个方法执行结束时,销毁一个栈帧
- 栈不存在垃圾回收问题

JVM规范允许虚拟机栈的大小是动态的或者是固定的
- 固定大小的虚拟机栈在创建时就被确定,不会改变
  - 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常
- 动态扩展的虚拟机栈在栈扩展时无法申请到足够的内存,会抛出OutOfMemoryError异常

#### 栈帧 -- 栈的存储单位

- 每个线程有自己的栈,栈的数据由栈帧组成
- 线程中正在执行的每个方法都对应一个栈帧
- 栈帧是一个内存区块,是一个数据集,维系着方法的执行状态

每个栈帧存储着:
- 局部变量表(Local Variables)
- 操作数栈(Operand Stack): 用于存储方法执行过程中的临时数据
- 动态链接(Dynamic Linking): 指向运行时常量池中该栈帧所属方法的引用
- 方法返回地址(Method Return Address): 指向方法的调用者
- 其他信息

![](img/JVM/栈帧的结构.png)

TODO:详细的栈帧结构

#### 栈运行原理

- JVM对栈的操作: 
  - 每个方法执行时,创建一个栈帧; 
  - 每个方法执行结束时,销毁一个栈帧
  - 遵循栈的"先进后出"原则
- 在一个活动线程的某一个时间点上,只有一个活动的栈帧,对应着当前正在执行的方法
- 所有字节码指令只针对当前栈帧进行操作
- 如果调用了其他方法,会创建新的栈帧,并压入栈顶
  - 在方法返回之后,栈帧会被销毁,并且栈顶的栈帧会成为当前栈帧
- 有两种返回指令: 
  - 一种是正常的方法返回指令, 
  - 另一种是异常返回指令


### 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。(C实现的)

本地方法栈也是线程私有的

允许线程请求本地方法栈的大小是动态的或者固定的


具体做法:
- 在`Native Method Stack`中登记native方法
- 在`Execution Engine`执行时,调用`Native Method Stack`中的方法
- 和虚拟机有同样的权限


在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

### Java堆

Java堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。

Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”。

作用: 存放对象实例，几乎所有的对象实例都在这里分配内存。

为了高效的进行GC, 堆内存**逻辑上**被划分为:
- 新生代(年轻代): 
  - 新对象
  - 还没到达一定年龄的对象
- 老年代: 
  - 被长时间使用的对象
  - 老年代的内存空间一般比新生代大很多
- 元空间:
  - JDK1.8前是永久代, 占用JVM内存
  - JDK1.8后是元空间, 占用系统内存

Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常


#### 年轻代

年轻代分为三个部分(分配一般为8:1:1)
- Eden区(伊甸园): 存放新创建的对象
- Survivor区(幸存者区): 存放经过一次GC后仍然存活的对象
  - Survivor区一般有两个, 一个是From, 一个是To
  - 每次GC后, Eden区和From Survivor区中的存活对象会被复制到To Survivor区
  - 每次GC后, From Survivor区和To Survivor区会交换角色

过程
- 新创建的对象会被分配到Eden区
- 当Eden区满时,会触发一次Minor GC,将Eden区中的存活对象复制到Survivor区
- Minor GC检查Survivor区中的存活对象,将存活对象复制到另一个Survivor区, 所以每次都有一个Survivor区是空的
- 经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.


#### 老年代

老年代主要存放经过多次GC仍然存活的对象。

老年代垃圾收集称为主GC

大对象直接进入老年代, 这样可以避免在Eden区和两个Survivor区之间来回复制大对象


#### 元空间

可以看作是 Java 虚拟机规范中方法区的实现。

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。


#### 设置堆大小 和 OOM

通过-Xmx 和 -Xms 控制堆的大小
- -Xmx: 最大堆大小
- -Xms: 初始堆大小

如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常

通常这两个参数设置成一样的值，可以减少堆大小调整的次数，从而提高性能。

默认情况下，Xmx是物理内存的1/4，Xms是1/64

堆内存的分配:
- 新生代:老年代 = 1:2, 通过-XX:NewRatio设置
- 新生代中的Eden:From:To = 8:1:1, 通过-XX:SurvivorRatio设置
 
每次GC后会重新计算Eden区和Survivor区的大小
计算依据是GC过程中统计的GC时间、吞吐量、内存占用量

#### 对象在堆的声明周期

- 对象的创建
- 对象被定义了一个 年轻对象计数器
- 当Eden空间不足时, Minor GC
  - Eden移动到Survivor区
  - 所有对象年龄+1
- 如果超过了-XX:PetenureSizeThreshold(默认15次), 分配到老年区


#### 对象的分配过程

- 老年区内存不足时, 触发Major GC
- 如果Major GC后, 仍然没有足够的内存, 抛出OOM异常

#### Minor GC、Major GC、Full GC

见[内存分配与回收](###内存分配与回收策略)

#### TLAB(Thread Local Allocation Buffer)

从内存模型角度, 对Eden区继续划分, 为每个线程分配一个私有的缓冲区, 在TLAB中分配对象, 减少线程间的竞争
这种内存分配方式称为快速分配策略

TLAB的意义
- 堆是线程共享的, 多线程并发分配对象时, 会出现竞争
- 对象实例的创建非常频繁, 因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。

#### 堆是分配对象的唯一选择吗？(逃逸分析)

不是, 有些对象不会分配到堆中.

逃逸分析(Escape Analysis)是可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法.

通过逃逸分析, 可以分析出一个新的对象的引用的使用范围, 如果发现一个对象的引用并没有逃逸出方法的话, 那么就可以将这个对象在栈上分配, 而不是在堆上分配.

基本行为, 分析对象动态作用域:
- 只在方法内部使用, 没有发生逃逸
- 被外部方法引用, 发生逃逸
  - 如返回值, 赋值给全局变量等

```java
public static StringBuffer craeteStringBuffer(String s1, String s2) {
   StringBuffer sb = new StringBuffer();
   sb.append(s1);
   sb.append(s2);
   return sb;
}
```
这样是发生逃逸的, 虽然它是一个局部变量,但还有可能被其他方法引用,所以会分配到堆上.

```java
public static String createStringBuffer(String s1, String s2) {
   StringBuffer sb = new StringBuffer();
   sb.append(s1);
   sb.append(s2);
   return sb.toString();
}
```
不直接返回StringBuffer, 而是返回String, 这样就不会发生逃逸, 可以分配到栈上.

在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析

编译器可以对代码做优化：
- 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
- 同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步分离对象或
- 标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器


### 方法区

方法区(Method Area)是各个线程共享的内存区域，它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法区有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。

常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

方法区的大小可以固定也可以扩展


方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）

#### 方法区的内部结构

方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

类型信息: 类型的全限定名、字段、方法、接口等信息

域信息: 域的名称、类型、修饰符等信息

方法信息: 方法的名称、参数、返回值、修饰符等信息

#### 运行时常量池

JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的


#### TODO: 方法区的垃圾回收



### Java对象在内存中的布局

![](img/JVM/Java对象在内存中的布局.png)

- 对象头(Header)
  - Mark Word: 存储对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息
  - Class Metadata Address: 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例
- 实例数据(Instance Data)
  - 存储对象真正有效的数据信息
- 对齐填充(Padding)
  - 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，填充数据不是必然存在的，仅仅是为了字节对齐


## JVM垃圾回收机制

### 判断一个对象是否可被回收

#### 引用计数法

引用计数法是一种最直观的判断对象是否可被回收的方法，它的基本思想是通过引用计数来判断一个对象是否可袝回收。

但由于循环引用的存在，这种方法并不可靠,JVM不使用

#### 可达性分析法

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

![](img/JVM/GC%20Roots.png)

GC Roots 一般包括:
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象


#### 方法区的回收


因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。

在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：类和接口的全限定名字段的名称和描述符方法的名称和描述符

HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收



判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：
- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

#### finalize()方法

finalize() 类似于 C++中的析构函数，用于对象在被垃圾收集器回收之前调用。

当一个对象可被回收时，垃圾收集器会调用该对象的 finalize() 方法，然后回收该对象。

通过finalize()方法，可以使对象在被回收之前进行一些清理工作，比如关闭文件、释放资源等。(自救,但只能进行一次)


### 引用类型

#### 强引用

强引用是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。

#### 软引用

被软引用关联的对象，只有在内存不足的时候才会被回收。

通过 SoftReference 类来实现软引用。

```java
SoftReference<Object> softRef = new SoftReference<Object>(new Object());
```

#### 弱引用

被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。

通过 WeakReference 类来实现弱引用。

```java
WeakReference<Object> weakRef = new WeakReference<Object>(new Object());
```

#### 虚引用

虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。

为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。

通过 PhantomReference 类来实现虚引用。

```java
ReferenceQueue<Object> rq = new ReferenceQueue<Object>();
PhantomReference<Object> pr = new PhantomReference<Object>(new Object(), rq);
```

### 垃圾收集算法

#### 标记-清除算法

![](img/JVM/标记清除.png)

将所有存活的对象标记，然后清除所有未标记的对象。

缺点:
- 标记和清除的效率都不高
- 标记清除之后会产生大量不连续的内存碎片

#### 标记-整理算法

![](img/JVM/标记整理.png)

标记-整理算法是标记-清除算法的升级版，它在标记阶段完成后，会将存活的对象向一端移动，然后直接清理掉边界外的内存。

#### 复制算法

![](img/JVM/复制.png)

将内存分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块内存上，然后清理掉原来的内存。

缺点:
- 内存使用率低
- 适用于新生代

#### 分代收集算法

根据对象存活周期的不同将内存划分为几块，一般是把堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。

### 垃圾收集器

![](img/JVM/HotSpot的七个垃圾收集器.png)

可以从两个维度来划分：
- 单线程和多线程: 单线程收集器只会使用一个线程进行垃圾回收，而多线程收集器则会使用多个线程进行垃圾回收。
- 串行和并行: 串行收集器是指在垃圾回收时只使用一个线程，而并行收集器则是指在垃圾回收时使用多个线程。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

#### Serial收集器

单线程、串行、Client模型的默认新生代收集器

优点：简单高效，对于单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程收集效率。

#### ParNew收集器

Serial收集器的多线程版本，Server模式下的默认新生代收集器

除了Serial外，只有它能和CMS收集器配合工作

#### Parallel Scavenge收集器

其它收集器关注点是尽可能**缩短垃圾收集时用户线程的停顿时间**，而它的目标是达到一个**可控制的吞吐量**，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

#### Serial Old收集器

Serial收集器的老年代版本，使用单线程进行垃圾回收

#### Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程进行垃圾回收

#### CMS收集器

CMS（Concurrent Mark-Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者 B/S 系统的服务端上的 Java 应用，这些应用都非常重视服务的响应速度。

Mark-Sweep（标记-清除）算法是 CMS 收集器的核心，它是一种获取最短回收停顿时间为目标的收集算法。

流程：
- 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿
- 并发标记: 进行 GC Roots Tracing 的过程， 耗时最长，不需要停顿
- 重新标记: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要停顿
- 并发清除: 与标记过程并发执行，不需要停顿

缺点
- 吞吐量低
- 无法处理浮动垃圾
- 由于 CMS 收集器是基于标记-清除算法实现的，所以在清除阶段会产生大量的空间碎片

#### G1收集器

G1（Garbage-First）收集器是一种面向服务端应用的垃圾收集器，适用于多核处理器和大容量内存的环境。

G1 收集器的设计目标是取代 CMS 收集器，它同样是一种并发并行的垃圾收集器。

堆被分为新生代和老年代，G1引入了Region的概念，将堆内存分为多个大小相等的Region，每个Region都有一个分代的角色，新生代和老年代不再是物理隔离的，而是逻辑上的概念。


G1 收集器的运作大致可划分为以下几个步骤:
- 初始标记
- 并发标记
- 最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
 
具备如下特点:
- 空间整合: 整体来看是基于“**标记-整理**”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
 

CMS更适合低延迟、对停顿时间敏感的应用,如web服务器、交易系统等。
G1更适合中大型堆、需要良好的吞吐量和可预测停顿时间的应用,如大数据处理系统、游戏服务器等。

### 内存分配与回收策略


针对HotSpot虚拟机,按照回收区域分为两大类:
- 部分收集
  - Minor GC/Young GC: 新生代的GC
  - Major GC/Old GC: 老年代的GC
    - 目前,只有CMS GC会有单独的Major GC
    - 很多时候, Major GC会和Full GC混在一起
  - Mixed GC: 混合收集, 收集整个新生代和部分老年代
    - 目前只有G1收集器会有Mixed GC
- 整堆收集
  - Full GC: 整堆收集,整个Java堆和方法区的垃圾

Major GC（Major Garbage Collection）和Mixed GC（Mixed Garbage Collection）是两种不同的垃圾回收机制，它们在执行时的行为和目标有所不同。

```md
  Major GC（也称为Full GC）是一种针对整个堆内存执行的垃圾回收操作。它的目标是清理整个堆内存，并回收无用对象。Major GC通常在堆内存空间不足或触发显式的垃圾回收请求时执行。它会停止应用程序的执行，并对整个堆内存进行标记和清理。Major GC的过程包括标记阶段和清理阶段，通过标记可达对象和清理未标记的对象来回收内存空间。

  Mixed GC（也称为Incremental GC）是一种结合了部分收集和全收集的垃圾回收操作。它的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。Mixed GC通过将堆内存划分为多个区域（如年轻代和老年代的不同区域）来实现增量的回收。它会在应用程序执行的同时，对某些区域进行标记和清理操作。这样可以减少垃圾回收的停顿时间，提高应用程序的响应性能。

  区别总结如下：

  范围：Major GC是对整个堆内存执行的垃圾回收操作，而Mixed GC是对部分堆内存区域执行的垃圾回收操作。
  目标：Major GC的目标是清理整个堆内存，并回收无用对象；Mixed GC的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。
  执行方式：Major GC会停止应用程序的执行，执行全面的标记和清理操作；Mixed GC会在应用程序执行的同时，对某些区域进行增量式的标记和清理操作。
  停顿时间：Major GC的停顿时间较长，会导致应用程序的暂停；Mixed GC采用增量式的回收，可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
  Java虚拟机和垃圾收集器的实现可以根据具体的需求和性能目标选择使用Major GC、Mixed GC或它们的组合来进行垃圾回收操作。
```
#### 内存分配策略

- 对象优先在Eden区分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判定
  - 如果在Eden区中经过一次Minor GC后,存活对象会被移动到Survivor区
  - 经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.
- 空间分配担保
  - 在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
  - 如果条件成立,则Minor GC可以确保是安全的
  - 如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败
    - 如果允许,则进行一次Full GC
    - 如果不允许,则改为进行一次Full GC

#### Full GC 的触发条件

- 调用 System.gc() 方法
- 老年代空间不足
- 空间分配担保失败
- CMS GC时出现Promotion Failure

## jvm的内存模型

### 什么叫零拷贝

零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。

在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。

### 为什么用常量池，有哪些常量池

https://blog.csdn.net/qq_41376740/article/details/80338158

常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：

1. 字面量常量池：用于存储字符串、数字等字面量常量。
2. 符号引用常量池：用于存储类、方法、字段等符号引用。
3. 运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。

使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。

