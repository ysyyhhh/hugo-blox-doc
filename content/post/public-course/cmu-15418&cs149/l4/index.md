---
title: 'L4 Parallel Programing basics'
date: 2024-03-01
lastmod: 2025-06-06
author: ['Ysyy']
categories: ['']
tags: ['cmu-15418&cs149']
description: ''
weight: None
draft: False
comments: True
showToc: True
TocOpen: True
hidemeta: False
disableShare: False
showbreadcrumbs: True
summary: ''
---
主要用三种方式实现并行程序(没有进行真正的优化)

例子 n-body simulation

![](img/2023-10-14-19-08-15.png)

创建并行程序的过程

![](img/2023-10-14-19-12-34.png)

### 1. Decomposition

主要思想: 创造至少足够的任务让所有的处理单元都有事情做

Amdahl's Law: 串行部分的比例越大, 并行程序的加速比就越小,因为增加处理单元的数量并不能减少串行部分的时间

![](img/2023-10-14-19-17-14.png)

![](img/2023-10-14-19-25-06.png)

分解的任务更多是程序员的工作, 编译器还无法很好的帮助我们

### 2.Assignment

![](img/2023-10-14-19-27-56.png)

需要考虑让每个处理单元尽可能减少沟通.

有一种方法是随机分配,但会最大化沟通
还有一个极端是全部由一个处理单元完成,但是这样就没有并行了

这是另一个挑战

分配可以静态也可以动态发生

静态: 在程序开始时就确定好.
动态: 在程序运行时分配
![](img/2023-10-14-19-32-26.png)

静态分配的问题:

- 无法适应不同的输入(如:工作量不均匀)
- 无法适应不同的处理单元数量

动态分配: 通过消息传递来实现, 每个处理单元都有一个队列, 用来存放需要处理的任务(tasks). 当一个处理单元完成了一个任务, 就从队列中取出一个任务来处理
![](img/2023-10-14-19-41-07.png)

缺点:
队列需要同步, 会有额外的开销

### 3. Orchestration 编排阶段

编排的目标是:
减少沟通和同步的成本, preserve **locality** of data reference, reduce overhead.

### 4.mapping

这是程序员最不需要关心的, 交给编译器就好了
![](img/2023-10-14-19-48-55.png)

## example

![](img/2023-10-14-20-28-08.png)

顺序程序:
![](img/2023-10-14-20-29-38.png)

那么如何并行执行呢?

### Step1: identify dependencies(problem decomposition)

因为会迭代很多次,所以会引起不同迭代次数的数据竞争.

有一种划分方法是沿着对角线:
![](img/2023-10-14-20-32-11.png)

不足之处是:

- 有些对角线很短, 负载不均衡
- 需要额外的计算(对角线下标)
  
另一种方法是滚动数组:
用两个数组, 一个用来存放当前迭代的结果, 一个用来存放上一次迭代的结果

这样计算时不会有数据竞争.

但很多人不希望有额外的内存开销.

事实上使用的是红黑排序.

![](img/2023-10-14-20-37-00.png)

每次迭代只更新红色的部分, 然后再翻转.
这样就不需要复制数组了.

### Step2: assign tasks

我们不把每一个元素作为一个任务,而是把每一行作为一个任务.

同时:
![](img/2023-10-14-20-41-36.png)

红黑排序有一个同步的步骤: 必须等待所有的红色部分都计算完毕, 才能开始计算黑色部分.

为了最小化沟通, 相邻行作为捆包是更好的选择, 这样只在更新边界时需要沟通.

### 三种实现方法

#### Data-parallel expression of solver

![](img/2023-10-14-20-45-17.png)

这个的特点是系统做了很多工作, 程序只需要指定哪里需要并行.

#### shared-address-space code

![](img/2023-10-14-20-49-07.png)

version1 :
![](img/2023-10-14-20-49-41.png)

但是有个锁会使得程序变慢
![](img/2023-10-14-20-51-52.png)

version2:
![](img/2023-10-14-20-53-12.png)

有三个barrier来保证红黑顺序
![](img/2023-10-14-20-54-07.png)
为什么是三个呢?

每一部分都要被分割

最后一个是为了diff的分割
第一个是为了myDiff的分割
第二个是为了diff的分割

所以可以使用diff数组

version3:
![](img/2023-10-14-20-57-40.png)

barrier的问题:
barrier还是有点笨重, 这会强制所有线程到一个起跑线
![](img/2023-10-14-20-59-07.png)

但如果有更精确的信息, 只需要等待依赖的线程就好了

#### message-passing code

![](img/2023-10-14-21-00-57.png)

需要有额外的划分,来存储相邻处理器的数据

![](img/2023-10-14-21-02-04.png)

同时,在最后计算diff时,需要等待所有的处理器都计算完毕.
这里选中了一个processor zero来计算diff, 其他的处理器都发送自己的diff给它.

![](img/2023-10-14-21-04-12.png)

但沟通时有可能发生死锁. 因为每个处理器都在等待其他处理器的消息, 但是自己的消息又没有发送出去.

![](img/2023-10-14-21-06-02.png)

所以需要分奇偶来发送

![](img/2023-10-14-21-07-24.png)